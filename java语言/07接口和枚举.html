<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>07接口和枚举</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://study1994.github.io/study_html/npm/prism.css"><link rel="stylesheet" href="https://study1994.github.io/study_html/npm/markmap-toolbar@0.13.5/dist/style.css">
</head>
<body>
    <svg id="mindmap"></svg>
    <script src="https://study1994.github.io/study_html/npm/d3@6.7.0"></script>
    <script src="https://study1994.github.io/study_html/npm/markmap-view@0.13.5"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
    <script>
        (r => {
            setTimeout(r);
        })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{'type': 'root', 'depth': 0, 'content': '', 'children': [{'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">导读</p>接口，是java提供的一个重要的类型，是对抽象类的进一步抽象。<br>\n通过接口的继承和接口回调技术，可以实现“多重继承”，并实现“行为”上的多态。<br>'}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">接口</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">接口的概念</p>\n<p>由<code>若干常量和方法声明</code>组成的集合<br>\n接口中的方法只有声明没有实现<br>\n在不同的地方被不同的类实<br>\n目的在于规范对象的行为，告诉接口的实现者必须做什么，但不要求怎么做，由实现者根据自身情况决定怎么做<br>\n接口中定义的常量是接口的特征属性，用于规范接口要求<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">接口的定义</p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<pre class="language-java"><code class="language-java">[修饰符] interface 接口名称 [extends父接口名列表]{\n    [public] [static] [final] 数据类型 变量名=常量值;\n    [public] [abstract] 返回值类型 方法名(参数列表);\n}\npublic interface Cubage{\t        // 一个接口Cubage，实现计算物体的体积\n    public static final double PI=3.1415926；\n    public abstract double doCubage();\n}\n</code></pre>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">接口与abstract类</p>\n<p>抽象类中既可以包含抽象方法，也可以包含非抽象的普通方法；而接口中所有的方法<code>必须是抽象方法</code>；<br>\n抽象类中的抽象方法的访问类型可以是public ，protected和默认类型，但接口中的抽象方法<code>只能是public类型的</code>；<br>\n抽象类中可以有普通成员变量，而接口中的所有变量均为public static final修饰，即<code>均为常量</code>；<br>\n抽象类里可以有构造方法，而接口内<code>不能有构造方法</code>；<br>\n一个类可以实现<code>多个接口</code>，但只能继承一个抽象类。<br></p>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">实现接口</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">用类实现接口</p>-<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<pre class="language-java"><code class="language-java">[修饰符] class 类名[extends 父类名] [implements 接口A,接口B,···]{\n    类成员变量和成员方法；\n    为接口A中的所有方法编写方法体，实现接口A；\n    为接口B中的所有方法编写方法体，实现接口B；\n}\n</code></pre>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">定义接口中的方法</p>如果一个非抽象类实现了某个接口，那么这个类就要重写接口中的所有方法<br>\n接口中的方法均用public abstract修饰，所以在类重写这些方法时也一定要用public进行修饰<br>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">接口与多态</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">接口中多态的概念</p>\n<p>接口多态是指不同的类在实现同一个接口时具有不同的实现过程，<br>\n当<code>接口变量</code>进行<code>回调接口方法</code>时就具有多种不同的形态<br>\n实现接口的多态性通常会使用到Java的<code>接口回调技术</code><br>\n接口回调本质上与继承中的上转型相同，不同之处是<br>\n接口回调是用<code>接口句柄</code>来获得并调用实现这个接口的子类的引用，<br>\n而上转型是用<code>父类句柄</code>来获得并调用实现此父类的子类的引用。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">通过接口实现多态</p>在接口定义时，将不同类的相同行为抽象出来成为接口，每个类对接口中的方法给出具体的行为实现。<br>\n当通过接口句柄调用方法时，系统会根据具体的子类对象决定执行哪个类中相应的方法，从而实现行为多态。<br>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">接口的设计与使用</p>接口主要是对不同类型的对象所具有的相同行为进行统一和规范，重点在于“行为”，而与类型无关，所以更适于功能扩展<br>'}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">枚举</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">概念</p>如果一个对象的所有值可以一一列举出来，则称为枚举。<br>\n在Java中，枚举类型也是一个类，用枚举类的变量表示枚举值。<br>\nJava定义了一个基础枚举类Enum，任何枚举类都是这个类的子类。使用枚举可以提高程序的清晰性和可读性。<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">简单的枚举类</p>\n<p>定义枚举类：<code>enum 枚举名{枚举常量表列}</code><br>\n定义枚举变量：<code>枚举名 枚举变量表列;</code><br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">复杂的枚举类</p>枚举类中除了枚举常量外，还可以定义域、方法、构造方法，main方法也可以定义在枚举类中。<br>\n如果在枚举类中定义了域和方法，则枚举常量必须放在枚举体内的第一行，而且最后一个枚举常量后要加一个“;”。<br>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">小结</p>本章主要介绍了接口和枚举。<br>\n首先，介绍了接口的基本概念和定义方法，然后讨论了接口和抽象类之间的区别。<br>\n面向接口编程是程序设计中比较难以掌握的部分，关键在于能否理解面向接口的设计思想。<br>\n枚举是将对象的所有值一一列举出来，使用枚举能够提高程序的可读性。<br>\nJava中的枚举不仅仅表示出常量，而且常量本身还可以有属性值，枚举类中还可以定义方法。<br>'}]})</script></body>
</html>
