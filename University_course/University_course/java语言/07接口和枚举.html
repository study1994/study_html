<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="http://zhao-study.gitee.io/code_html/tools/prism.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="http://zhao-study.gitee.io/code_html/tools/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.7"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(), data);
      })(() => window.markmap,null,{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"导读","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"接口，是java提供的一个重要的类型，是对抽象类的进一步抽象。"},{"t":"list_item","d":3,"p":{"lines":[2,3]},"v":"通过接口的继承和接口回调技术，可以实现“多重继承”，并实现“行为”上的多态。"}]},{"t":"heading","d":1,"p":{"lines":[4,5]},"v":"接口","c":[{"t":"heading","d":2,"p":{"lines":[5,6]},"v":"接口的概念","c":[{"t":"list_item","d":4,"p":{"lines":[6,7]},"v":"由<code>若干常量和方法声明</code>组成的集合"},{"t":"list_item","d":4,"p":{"lines":[7,8]},"v":"接口中的方法只有声明没有实现"},{"t":"list_item","d":4,"p":{"lines":[8,9]},"v":"在不同的地方被不同的类实"},{"t":"list_item","d":4,"p":{"lines":[9,10]},"v":"目的在于规范对象的行为，告诉接口的实现者必须做什么，但不要求怎么做，由实现者根据自身情况决定怎么做"},{"t":"list_item","d":4,"p":{"lines":[10,11]},"v":"接口中定义的常量是接口的特征属性，用于规范接口要求"}]},{"t":"heading","d":2,"p":{"lines":[11,12]},"v":"接口的定义","c":[{"t":"bullet_list","d":3,"p":{"lines":[12,13]},"v":""},{"t":"fence","d":3,"v":"<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span>修饰符<span class=\"token punctuation\">]</span> <span class=\"token keyword\">interface</span> 接口名称 <span class=\"token punctuation\">[</span><span class=\"token keyword\">extends</span>父接口名列表<span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">public</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">static</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">final</span><span class=\"token punctuation\">]</span> 数据类型 变量名<span class=\"token operator\">=</span>常量值<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">public</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">abstract</span><span class=\"token punctuation\">]</span> 返回值类型 方法名<span class=\"token punctuation\">(</span>参数列表<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n"},{"t":"bullet_list","d":3,"p":{"lines":[19,20]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[19,20]},"v":"一个接口Cubage，实现计算物体的体积"}]},{"t":"fence","d":3,"v":"<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Cubage</span><span class=\"token punctuation\">{</span>    \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">double</span> PI<span class=\"token operator\">=</span><span class=\"token number\">3.1415926</span>；\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">double</span> <span class=\"token function\">doCubage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n"}]},{"t":"heading","d":2,"p":{"lines":[26,27]},"v":"接口与abstract类","c":[{"t":"list_item","d":4,"p":{"lines":[27,28]},"v":"抽象类中既可以包含抽象方法，也可以包含非抽象的普通方法；而接口中所有的方法<code>必须是抽象方法</code>；"},{"t":"list_item","d":4,"p":{"lines":[28,29]},"v":"抽象类中的抽象方法的访问类型可以是public ，protected和默认类型，但接口中的抽象方法<code>只能是public类型的</code>；"},{"t":"list_item","d":4,"p":{"lines":[29,30]},"v":"抽象类中可以有普通成员变量，而接口中的所有变量均为public static final修饰，即<code>均为常量</code>；"},{"t":"list_item","d":4,"p":{"lines":[30,31]},"v":"抽象类里可以有构造方法，而接口内<code>不能有构造方法</code>；"},{"t":"list_item","d":4,"p":{"lines":[31,32]},"v":"一个类可以实现<code>多个接口</code>，但只能继承一个抽象类。"}]}]},{"t":"heading","d":1,"p":{"lines":[33,34]},"v":"实现接口","c":[{"t":"heading","d":2,"p":{"lines":[34,35]},"v":"用类实现接口","c":[{"t":"bullet_list","d":3,"p":{"lines":[35,36]},"v":""},{"t":"fence","d":3,"v":"<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span>修饰符<span class=\"token punctuation\">]</span> <span class=\"token keyword\">class</span> 类名<span class=\"token punctuation\">[</span><span class=\"token keyword\">extends</span> 父类名<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">implements</span> 接口<span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span>接口<span class=\"token class-name\">B</span><span class=\"token punctuation\">,</span>···<span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span>\n    类成员变量和成员方法；\n    为接口<span class=\"token class-name\">A</span>中的所有方法编写方法体，实现接口<span class=\"token class-name\">A</span>；\n    为接口<span class=\"token class-name\">B</span>中的所有方法编写方法体，实现接口<span class=\"token class-name\">B</span>；\n<span class=\"token punctuation\">}</span>\n</code></pre>\n"}]},{"t":"heading","d":2,"p":{"lines":[43,44]},"v":"定义接口中的方法","c":[{"t":"list_item","d":4,"p":{"lines":[44,45]},"v":"如果一个非抽象类实现了某个接口，那么这个类就要重写接口中的所有方法"},{"t":"list_item","d":4,"p":{"lines":[45,46]},"v":"接口中的方法均用public abstract修饰，所以在类重写这些方法时也一定要用public进行修饰"}]}]},{"t":"heading","d":1,"p":{"lines":[48,49]},"v":"接口与多态","c":[{"t":"heading","d":2,"p":{"lines":[49,50]},"v":"接口中多态的概念","c":[{"t":"list_item","d":4,"p":{"lines":[50,52]},"v":"接口多态是指不同的类在实现同一个接口时具有不同的实现过程，<br>\n当<code>接口变量</code>进行<code>回调接口方法</code>时就具有多种不同的形态"},{"t":"list_item","d":4,"p":{"lines":[52,53]},"v":"实现接口的多态性通常会使用到Java的<code>接口回调技术</code>"},{"t":"list_item","d":4,"p":{"lines":[53,56]},"v":"接口回调本质上与继承中的上转型相同，不同之处是<br>\n接口回调是用<code>接口句柄</code>来获得并调用实现这个接口的子类的引用，<br>\n而上转型是用<code>父类句柄</code>来获得并调用实现此父类的子类的引用。"}]},{"t":"heading","d":2,"p":{"lines":[56,57]},"v":"通过接口实现多态","c":[{"t":"list_item","d":4,"p":{"lines":[57,58]},"v":"在接口定义时，将不同类的相同行为抽象出来成为接口，每个类对接口中的方法给出具体的行为实现。"},{"t":"list_item","d":4,"p":{"lines":[58,59]},"v":"当通过接口句柄调用方法时，系统会根据具体的子类对象决定执行哪个类中相应的方法，从而实现行为多态。"}]}]},{"t":"heading","d":1,"p":{"lines":[61,62]},"v":"接口的设计与使用","c":[{"t":"list_item","d":3,"p":{"lines":[62,63]},"v":"接口主要是对不同类型的对象所具有的相同行为进行统一和规范，重点在于“行为”，而与类型无关，所以更适于功能扩展"}]},{"t":"heading","d":1,"p":{"lines":[64,65]},"v":"枚举","c":[{"t":"heading","d":2,"p":{"lines":[65,66]},"v":"概念","c":[{"t":"list_item","d":4,"p":{"lines":[66,67]},"v":"如果一个对象的所有值可以一一列举出来，则称为枚举。"},{"t":"list_item","d":4,"p":{"lines":[67,68]},"v":"在Java中，枚举类型也是一个类，用枚举类的变量表示枚举值。"},{"t":"list_item","d":4,"p":{"lines":[68,69]},"v":"Java定义了一个基础枚举类Enum，任何枚举类都是这个类的子类。使用枚举可以提高程序的清晰性和可读性。"}]},{"t":"heading","d":2,"p":{"lines":[69,70]},"v":"简单的枚举类","c":[{"t":"list_item","d":4,"p":{"lines":[70,71]},"v":"定义枚举类：<code>enum 枚举名{枚举常量表列}</code>"},{"t":"list_item","d":4,"p":{"lines":[71,72]},"v":"定义枚举变量：<code>枚举名 枚举变量表列;</code>"}]},{"t":"heading","d":2,"p":{"lines":[72,73]},"v":"复杂的枚举类","c":[{"t":"list_item","d":4,"p":{"lines":[73,74]},"v":"枚举类中除了枚举常量外，还可以定义域、方法、构造方法，main方法也可以定义在枚举类中。"},{"t":"list_item","d":4,"p":{"lines":[74,75]},"v":"如果在枚举类中定义了域和方法，则枚举常量必须放在枚举体内的第一行，而且最后一个枚举常量后要加一个“;”。"}]}]},{"t":"heading","d":1,"p":{"lines":[76,77]},"v":"小结","c":[{"t":"list_item","d":3,"p":{"lines":[77,78]},"v":"本章主要介绍了接口和枚举。"},{"t":"list_item","d":3,"p":{"lines":[78,79]},"v":"首先，介绍了接口的基本概念和定义方法，然后讨论了接口和抽象类之间的区别。"},{"t":"list_item","d":3,"p":{"lines":[79,80]},"v":"面向接口编程是程序设计中比较难以掌握的部分，关键在于能否理解面向接口的设计思想。"},{"t":"list_item","d":3,"p":{"lines":[80,81]},"v":"枚举是将对象的所有值一一列举出来，使用枚举能够提高程序的可读性。"},{"t":"list_item","d":3,"p":{"lines":[81,82]},"v":"Java中的枚举不仅仅表示出常量，而且常量本身还可以有属性值，枚举类中还可以定义方法。"}]}],"p":{}})</script>
</body>
</html>
