<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="http://zhao-study.gitee.io/code_html/tools/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.7"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(), data);
      })(() => window.markmap,null,{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"子类及其对象","c":[{"t":"heading","d":2,"p":{"lines":[1,2]},"v":"子类定义","c":[{"t":"list_item","d":4,"p":{"lines":[2,3]},"v":"class 子类名 extends 父类名{}"},{"t":"list_item","d":4,"p":{"lines":[3,4]},"v":"只支持单重继承。除了Object类之外每个类都有一个父类"}]},{"t":"heading","d":2,"p":{"lines":[4,5]},"v":"子类的可访问性","c":[{"t":"heading","d":3,"p":{"lines":[5,6]},"v":"私有成员：可以被继承，只能通过<code>继承自父类的</code>并且<code>子类可以访问</code>的方法间接访问"},{"t":"heading","d":3,"p":{"lines":[6,7]},"v":"公有成员：可以被子类中的方法直接访问，在子类类体外可以通过子类对象访问"},{"t":"heading","d":3,"p":{"lines":[7,8]},"v":"保护成员","c":[{"t":"list_item","d":5,"p":{"lines":[8,9]},"v":"在同一个包中：可以被子类中的方法直接访问，在子类类体外<code>可以</code>通过子类对象访问"},{"t":"list_item","d":5,"p":{"lines":[9,10]},"v":"不在一个包中：可以被子类中的方法直接访问，在子类类体外<code>不可以</code>通过子类对象访问"}]},{"t":"heading","d":3,"p":{"lines":[10,11]},"v":"友好成员","c":[{"t":"list_item","d":5,"p":{"lines":[11,12]},"v":"在同一个包中：可以被子类中的方法直接访问，在子类类体外<code>可以</code>通过子类对象访问"},{"t":"list_item","d":5,"p":{"lines":[12,15]},"v":"不在一个包中：<br>\n<code>不可以</code>被子类中的方法直接访问，在子类类体外<code>不可以</code>通过子类对象访问<br>\n只能通过<code>继承自父类的</code>并且<code>子类可以访问</code>的方法间接访问"}]}]},{"t":"heading","d":2,"p":{"lines":[15,16]},"v":"instanceof运算符","c":[{"t":"list_item","d":4,"p":{"lines":[16,17]},"v":"判断一个对象是否是某一个类的实例对象"},{"t":"list_item","d":4,"p":{"lines":[17,18]},"v":"对象名 instanceof 类名"}]}]},{"t":"heading","d":1,"p":{"lines":[19,20]},"v":"域的隐藏和方法的重写","c":[{"t":"heading","d":2,"p":{"lines":[20,21]},"v":"域的隐藏","c":[{"t":"list_item","d":4,"p":{"lines":[21,22]},"v":"方法的重写:将继承自父类的方法重新定义"},{"t":"list_item","d":4,"p":{"lines":[22,23]},"v":"定义的域的名字与继承自父类的域的名字相同"}]},{"t":"heading","d":2,"p":{"lines":[23,24]},"v":"super关键字","c":[{"t":"list_item","d":4,"p":{"lines":[24,25]},"v":"super表示当前类的直接父类"},{"t":"list_item","d":4,"p":{"lines":[25,26]},"v":"访问继承自父类中的域:<code>super.域名</code>"},{"t":"list_item","d":4,"p":{"lines":[26,27]},"v":"调用继承自父类中的方法:<code>super.方法名([实际参数])</code>"},{"t":"list_item","d":4,"p":{"lines":[27,28]},"v":"调用直接父类的构造方法:<code>super([实际参数]);</code>"},{"t":"list_item","d":4,"p":{"lines":[28,29]},"v":"父类的实例初始化器→父类的构造方法→子类的实例初始化器→子类的构造方法"}]}]},{"t":"heading","d":1,"p":{"lines":[29,30]},"v":"对象的赋值兼容规则","c":[{"t":"heading","d":2,"p":{"lines":[30,31]},"v":"赋值兼容规则:用父类对象表示子类的对象","c":[{"t":"list_item","d":4,"p":{"lines":[31,33]},"v":"父类对象表示子类对象时，父类对象称为子类对象的上转型对象<br>\n类B是类A的子类:<code>A a=new B();</code>a-&gt;上转型对象"},{"t":"list_item","d":4,"p":{"lines":[33,34]},"v":"父类对象强制转换成子类对象<code>B b=(B)a;</code>b-&gt;下转型对象"}]},{"t":"heading","d":2,"p":{"lines":[34,35]},"v":"用一个父类对象表示子类对象后，父类对象","c":[{"t":"list_item","d":4,"p":{"lines":[35,36]},"v":"可以访问子类继承自父类的域或被子类隐藏的域；"},{"t":"list_item","d":4,"p":{"lines":[36,37]},"v":"可以调用子类继承自父类的方法或被子类重写的方法；"},{"t":"list_item","d":4,"p":{"lines":[37,38]},"v":"不能访问子类相对于父类新增加的域或方法。"}]},{"t":"heading","d":2,"p":{"lines":[38,39]},"v":"使用赋值兼容规则主要是为了实现多态性"}]},{"t":"heading","d":1,"p":{"lines":[40,41]},"v":"final关键字","c":[{"t":"heading","d":2,"p":{"lines":[41,42]},"v":"最终类:<code>final class 类名{}</code>","c":[{"t":"list_item","d":4,"p":{"lines":[42,43]},"v":"对类起到保护作用,典型的最终类就是String类"}]},{"t":"heading","d":2,"p":{"lines":[43,44]},"v":"最终方法:<code>[访问限定词] [static] final 方法类型 方法名([参数]){}</code>","c":[{"t":"list_item","d":4,"p":{"lines":[44,45]},"v":"可以被子类继承，但不能被子类重写"}]},{"t":"heading","d":2,"p":{"lines":[45,46]},"v":"最终域-常量:<code>[访问限定词] [static] final 数据类型 域名=初值;</code>"}]},{"t":"heading","d":1,"p":{"lines":[47,48]},"v":"多态","c":[{"t":"heading","d":2,"p":{"lines":[48,49]},"v":"同一类对象表现出的不同行为称为多态"},{"t":"heading","d":2,"p":{"lines":[49,50]},"v":"在有继承关系的对象中,每一个<code>子类的对象</code>的行为都与其它<code>子类对象</code>或<code>父类对象</code>的行为不同，这种行为上的不同称为多态性。"},{"t":"heading","d":2,"p":{"lines":[50,51]},"v":"多态的实现","c":[{"t":"list_item","d":4,"p":{"lines":[51,52]},"v":"定义一个基类，在此基类基础上再派生出若干个子类；"},{"t":"list_item","d":4,"p":{"lines":[52,53]},"v":"子类要重写父类中的方法，使子类对象能够表现出子类的行为；"},{"t":"list_item","d":4,"p":{"lines":[53,54]},"v":"用父类对象名表示子类对象（赋值兼容规则）；"},{"t":"list_item","d":4,"p":{"lines":[54,55]},"v":"通过父类对象名调用被子类重写的方法。"}]}]},{"t":"heading","d":1,"p":{"lines":[56,57]},"v":"abstract关键字","c":[{"t":"heading","d":2,"p":{"lines":[57,58]},"v":"抽象类:<code>abstract class 类名{}</code>","c":[{"t":"list_item","d":4,"p":{"lines":[58,59]},"v":"抽象类不能生成对象实例"}]},{"t":"heading","d":2,"p":{"lines":[59,60]},"v":"抽象方法:<code>[访问限定词] abstract 数据类型 方法名([参数表列]);</code>","c":[{"t":"list_item","d":4,"p":{"lines":[60,61]},"v":"抽象方法只有方法的头部，没有方法体。抽象方法一定不能用关键字final修饰。"},{"t":"list_item","d":4,"p":{"lines":[61,62]},"v":"抽象类中可以有非抽象（实例）方法，也可以有抽象方法。如果一个类中有抽象方法，该类必须定义成抽象类。"}]}]},{"t":"heading","d":1,"p":{"lines":[63,64]},"v":"小结","c":[{"t":"list_item","d":3,"p":{"lines":[64,65]},"v":"通过继承，可以实现代码重用，提高编程效率，提高程序运行的稳定性。继承是实现多态性的前提。"},{"t":"list_item","d":3,"p":{"lines":[65,67]},"v":"继承过程中，子类可以定义与父类同名的域，则在子类中隐藏了父类的域；子类还可以将继承自父类的方法重写。<br>\n在子类对象中，如果想访问父类中被隐藏的域或调用父类中被重写的方法，可以用关键字super。"},{"t":"list_item","d":3,"p":{"lines":[67,68]},"v":"父类对象可以表示子类对象，称为类型兼容规则。"},{"t":"list_item","d":3,"p":{"lines":[68,69]},"v":"多态性指的是同一类对象具有的不同行为，具有指的是有共同父类的子类对象的不同行为。"},{"t":"list_item","d":3,"p":{"lines":[69,70]},"v":"如果父类没有必要创建实例，则可以声明为抽象类。如果不希望一个类有子类，则可以将该类声明为最终类。"}]}],"p":{}})</script>
</body>
</html>
