<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="http://zhao-study.gitee.io/code_html/tools/prism.css"><link rel="stylesheet" href="http://zhao-study.gitee.io/code_html/tools/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="http://zhao-study.gitee.io/code_html/tools/d3@6.7.0"></script><script src="http://zhao-study.gitee.io/code_html/tools/markmap-view@0.13.2"></script><script src="http://zhao-study.gitee.io/code_html/tools/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(markmap, jsonOptions), root);
      })(() => window.markmap,(markmap, jsonOptions) => markmap.deriveOptions(jsonOptions),{"type":"root","depth":0,"content":"","children":[{"type":"heading","depth":1,"payload":{"lines":[0,1]},"content":"概述","children":[{"type":"list_item","depth":3,"payload":{"lines":[1,4]},"content":"一个较大的程序一般应分为若干个模块，每个模块实现一个特定的功能。<br>\n这种结构化程序设计有许多优点，首先可以避免程序的重复，提高程序的重用率；<br>\n其次程序划分成若干模块后，可以由多人同时设计，从而缩短程序设计的周期。"}]},{"type":"heading","depth":1,"payload":{"lines":[4,5]},"content":"函数的定义和调用","children":[{"type":"fence","depth":2,"content":"<pre class=\"language-c\"><code class=\"language-c\"><span class=\"token punctuation\">[</span>函数类型说明符<span class=\"token punctuation\">]</span> 函数名<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>形式参数声明列表<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    函数体\n<span class=\"token punctuation\">}</span>\n</code></pre>\n"},{"type":"heading","depth":2,"payload":{"lines":[10,11]},"content":"函数声明:<code>类型说明符 函数名(形参表);</code>"},{"type":"heading","depth":2,"payload":{"lines":[11,12]},"content":"函数调用:<code>函数名(实参列表);</code>"},{"type":"heading","depth":2,"payload":{"lines":[12,13]},"content":"可以不在主调函数中对被调函数进行声明","children":[{"type":"list_item","depth":4,"payload":{"lines":[13,14]},"content":"被调函数写在主调函数的前面"},{"type":"list_item","depth":4,"payload":{"lines":[14,15]},"content":"函数的返回值为整型或字符型"},{"type":"list_item","depth":4,"payload":{"lines":[15,16]},"content":"在所有函数定义之前,在源程序文件的开头"},{"type":"list_item","depth":4,"payload":{"lines":[16,17]},"content":"对库函数的调用有<code>include</code>不需要声明"}]},{"type":"heading","depth":2,"payload":{"lines":[17,18]},"content":"3种函数调用","children":[{"type":"list_item","depth":4,"payload":{"lines":[18,19]},"content":"函数表达式"},{"type":"list_item","depth":4,"payload":{"lines":[19,20]},"content":"函数语句"},{"type":"list_item","depth":4,"payload":{"lines":[20,21]},"content":"函数作为实参"}]}]},{"type":"heading","depth":1,"payload":{"lines":[22,23]},"content":"函数的参数传递和返回值","children":[{"type":"heading","depth":2,"payload":{"lines":[23,24]},"content":"实参的值传递给形参，是一个单向传递的过程"}]},{"type":"heading","depth":1,"payload":{"lines":[25,26]},"content":"函数的嵌套调用"},{"type":"heading","depth":1,"payload":{"lines":[26,27]},"content":"函数的递归调用"},{"type":"heading","depth":1,"payload":{"lines":[27,28]},"content":"变量的作用域及存储类别","children":[{"type":"heading","depth":2,"payload":{"lines":[28,29]},"content":"存储空间分为三部分","children":[{"type":"list_item","depth":4,"payload":{"lines":[29,30]},"content":"程序区:可执行的机器指令；"},{"type":"list_item","depth":4,"payload":{"lines":[30,31]},"content":"静态存储区:需要占用固定存储单元的变量；"},{"type":"list_item","depth":4,"payload":{"lines":[31,32]},"content":"动态存储区:不需要占用固定存储单元的变量"}]},{"type":"heading","depth":2,"payload":{"lines":[32,33]},"content":"变量","children":[{"type":"heading","depth":3,"payload":{"lines":[33,34]},"content":"变量的数据类型，如int，char，float等"},{"type":"heading","depth":3,"payload":{"lines":[34,35]},"content":"变量的作用域","children":[{"type":"list_item","depth":5,"payload":{"lines":[35,36]},"content":"局部变量"},{"type":"list_item","depth":5,"payload":{"lines":[36,39]},"content":"全局变量<br>\n定义点之前的函数需要引用这些全局变量<br>\nextern 数据类型 全局变量[,全局变量2…];"}]},{"type":"heading","depth":3,"payload":{"lines":[39,40]},"content":"变量的存储类型:不同的存储方法影响变量值的存在时间","children":[{"type":"list_item","depth":5,"payload":{"lines":[40,41]},"content":"静态存储:全局变量，静态变量"},{"type":"list_item","depth":5,"payload":{"lines":[41,42]},"content":"动态存储:自动变量和寄存器变量"}]},{"type":"heading","depth":3,"payload":{"lines":[42,43]},"content":"四种存储类别","children":[{"type":"list_item","depth":5,"payload":{"lines":[43,45]},"content":"auto：自动变量-局部变量<br>\nauto int a,b=5;(auto可以省略)"},{"type":"list_item","depth":5,"payload":{"lines":[45,47]},"content":"static：静态变量<br>\n静态局部变量+静态全局变量"},{"type":"list_item","depth":5,"payload":{"lines":[47,49]},"content":"extern：外部变量<br>\n在一个文件中要引用其他文件中定义的全局变量"},{"type":"list_item","depth":5,"payload":{"lines":[49,52]},"content":"register：寄存器变量<br>\n变量存放在CPU的寄存器中,使用时不需要访问内存,而是直接从寄存器中读写<br>\n循环次数较多的循环控制变量及循环体内反复使用的变量"}]}]}]},{"type":"heading","depth":1,"payload":{"lines":[52,53]},"content":"内部函数及外部函数","children":[{"type":"heading","depth":2,"payload":{"lines":[53,54]},"content":"这些函数能否被其他源文件调用"},{"type":"heading","depth":2,"payload":{"lines":[54,55]},"content":"内部函数又称静态函数","children":[{"type":"list_item","depth":4,"payload":{"lines":[55,56]},"content":"static 函数类型标识符 函数名(形参)"},{"type":"list_item","depth":4,"payload":{"lines":[56,57]},"content":"在不同的文件中有同名的内部函数，则互不干扰"}]},{"type":"heading","depth":2,"payload":{"lines":[57,58]},"content":"外部函数","children":[{"type":"list_item","depth":4,"payload":{"lines":[58,61]},"content":"extern 类型说明符 函数名(形参表)<br>\nextern void output_char( char a)<br>\n在定义函数时省略了extern，则默认为外部函数。本书前面所用的函数都是外部函数。"}]}]}],"payload":{}},{})</script>
</body>
</html>
