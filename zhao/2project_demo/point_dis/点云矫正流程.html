<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>点云矫正流程</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
.hidden-code {
  display: none !important;
}
</style>
<link rel="stylesheet" href="https://study1994.github.io/study_html/npm/mycss/style.css">
</head>
<body>
    <svg id="mindmap"></svg>
    <script src="https://study1994.github.io/study_html/npm/myjs/d3@6.7.0.js"></script>
    <script src="https://study1994.github.io/study_html/npm/myjs/markmap-view@0.13.5.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
    <script>
        (r => {
            setTimeout(r);
        })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{'type': 'root', 'depth': 0, 'content': '', 'children': [{'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">app/undistord.cc</p><span class=\'hidden-code\' data-code=\'int main(int argc, char **argv){\n    Undistored `undistored`(&amp;#39;./config/test.yaml&amp;#39;);\n    while (undistored.Finished()){\n        sleep(1);\n    }\n    return 0;\n}\n\'> </span>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">app/undistord.cc</p><span class=\'hidden-code\' data-code=\'Undistored::Undistored(const std::string &amp;cfg_path){\n    `init`(cfg_path);\n    project_lidar.defalt();\n    if (access((&amp;#39;./result&amp;#39;), 0) == 0){\n        cout << &amp;#39;------------------result already exist!--------------------------&amp;#39; << endl;\n        log_txt.open(&amp;#39;./result/log.txt&amp;#39;, ios::out);\n    }\n    else{\n        cout << &amp;#39;-------------------------creat result !--------------------------&amp;#39; << endl;\n        mkdir((&amp;#39;./result&amp;#39;), S_IRWXU);\n        mkdir((&amp;#39;./result/img&amp;#39;), S_IRWXU);\n        mkdir((&amp;#39;./result/pcd&amp;#39;), S_IRWXU);\n        log_txt.open(&amp;#39;./result/log.txt&amp;#39;, ios::out);\n    }\n}\n\'> </span>', 'children': [{'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">source/pipeline.cpp</p><span class=\'hidden-code\' data-code=\'void PipeLine::init(const std::string &amp;cfg_path){\n    is_run_ = true;\n    rtk_deq_.clear();\n    imu_deq_.clear();\n    vehicle_deq_.clear();\n    video_deq_.clear();\n    lidar_deq_.clear();\n    YAML::Node cfg = YAML::LoadFile(cfg_path);\n    std::string data_path = cfg[&amp;#39;path&amp;#39;].as`<`std::string`>`();    // &amp;#39;/mnt/Minieye_GT_Nas/Minieye_GT_Dataset//EP40_C90776/20240328/seq_01&amp;#39;\n    log_ = cfg[&amp;#39;log&amp;#39;].as`<`int`>`();                              // 0\n    cache_ = cfg[&amp;#39;cache&amp;#39;].as`<`int`>`();                          // 10\n    trigger_sensor_ = MsgType(cfg[&amp;#39;trigger&amp;#39;].as`<`int`>`());  \n    rtk_loader_ptr_ = std::make_shared`<``ParseRtk``>`(cfg_path);\n    imu_loader_ptr_ = std::make_shared`<``ParseImu``>`(cfg_path);\n    vehicle_loader_ptr_ = std::make_shared`<``ParseVehicle``>`(cfg_path);\n    video_loader_ptr_ = std::make_shared`<``ParseVideo``>`(cfg_path);\n    lidar_loader_ptr_ = std::make_shared`<``ParseLidar``>`(cfg_path);\n    thr_get_ = std::make_shared`<`std::thread`>`(&amp;PipeLine::`GetData`, this);\n    thr_out_ = std::make_shared`<`std::thread`>`(&amp;PipeLine::`Output`, this);\n    thr_print_ = std::make_shared`<`std::thread`>`(&amp;PipeLine::`PrintLog`, this);\n}\n\'> </span>', 'children': [{'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">source/parse_rtk.cpp</p><span class=\'hidden-code\' data-code=\'ParseRtk::ParseRtk(const std::string &amp;cfg_path){\n    rtk_deq_.clear();\n    YAML::Node cfg = YAML::LoadFile(cfg_path);\n    std::string data_path = cfg[&amp;#39;path&amp;#39;].as`<`std::string`>`();             // 20240328/seq_01\n    cache_ = cfg[&amp;#39;cache&amp;#39;].as`<`int`>`();                                   // 10\n    if (data_path.empty()){\n        return;\n    }\n    odo_log_ = data_path + cfg[&amp;#39;odo_name&amp;#39;].as`<`std::string`>`();          // &amp;#39;/....../seq_01/rtk/odometry_x16h.txt&amp;#39;\n    thr_ = std::make_shared`<`std::thread`>`(&amp;ParseRtk::`Parse`, this);\n}\n\'> </span>', 'children': [{'type': 'heading', 'depth': 5, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">source/parse_rtk.cpp</p><span class=\'hidden-code\' data-code=\'void ParseRtk::Parse(){\n    std::ifstream olog(odo_log_.c_str(), std::ios::in);                \n    std::string oline = &amp;#39;&amp;#39;;\n    if (! olog.is_open()){\n        std::cout << &amp;#39;Load odo file failed : &amp;#39; << odo_log_ << std::endl;  // 这个没用到了\n    }\n    else{\n        std::cout << &amp;#39;Load odo file: &amp;#39; << odo_log_ << std::endl;\n    }\n    while (getline(olog, oline)){              // False都未执行\n        while (CheckCache()){\n            usleep(1e5);\n        }\n        std::deque`<`std::string`>` infos = SplitString(oline, &amp;#39;,&amp;#39;);\n        if (infos[0] == &amp;#39;%time&amp;#39;){\n            continue;\n        }\n        // 落盘时间 ns \n        uint32_t timestamp_s = static_cast`<`uint32_t`>`(std::stoi(infos[0].substr(0,10)));\n        uint32_t timestamp_ns = static_cast`<`uint32_t`>`(std::stoi(infos[0].substr(10)));\n        uint32_t seq = static_cast`<`uint32_t`>`(std::stoi(infos[1]));\n        // GPS时间 ns \n        uint32_t generate_time_s = static_cast`<`uint32_t`>`(std::stoi(infos[2].substr(0,10)));\n        uint32_t generate_time_ns = static_cast`<`uint32_t`>`(std::stoi(infos[2].substr(10)));\n        double generate_time = (double)generate_time_s +  (double)generate_time_ns * 1e-9;\n        std::string frame_id = infos[3];\n        double pos_wgs84_x = std::stod(infos[5]);\n        double pos_wgs84_y = std::stod(infos[6]);\n        double pos_wgs84_z = std::stod(infos[7]);\n        double ori_x = std::stod(infos[8]);\n        double ori_y = std::stod(infos[9]);\n        double ori_z = std::stod(infos[10]);\n        double ori_w = std::stod(infos[11]);\n        Eigen::Quaterniond quat(ori_w, ori_x, ori_y, ori_z);\n        Sophus::SO3`<`double`>` rot_mat(quat.matrix());\n        Eigen::Matrix`<`double, 3, 1`>` rot_vector = rot_mat.log();\n        double linear_x = std::stod(infos[48]);\n        double linear_y = std::stod(infos[49]);\n        double linear_z = std::stod(infos[50]);\n        minieye::slam::Time *timestamp_ptr = new minieye::slam::Time();\n        timestamp_ptr->set_sec(timestamp_s);\n        timestamp_ptr->set_nsec(timestamp_ns);\n        minieye::slam::Time *generate_time_ptr = new minieye::slam::Time();\n        generate_time_ptr->set_sec(generate_time_s);\n        generate_time_ptr->set_nsec(generate_time_ns);\n        minieye::slam::Time *tick_ptr = new minieye::slam::Time();\n        tick_ptr->set_sec(generate_time_s);\n        tick_ptr->set_nsec(generate_time_ns);\n        minieye::slam::Header *header_ptr = new minieye::slam::Header();\n        header_ptr->set_allocated_timestamp(timestamp_ptr);\n        header_ptr->set_allocated_generate_time(generate_time_ptr);\n        header_ptr->set_allocated_tick(tick_ptr);\n        header_ptr->set_frame_id(frame_id);\n        header_ptr->set_seq(seq);\n        minieye::slam::Point3d *pos_wgs84_ptr = new minieye::slam::Point3d();\n        pos_wgs84_ptr->set_x(pos_wgs84_x);\n        pos_wgs84_ptr->set_y(pos_wgs84_y);\n        pos_wgs84_ptr->set_z(pos_wgs84_z);\n        minieye::slam::Point3d *orientation_ptr = new minieye::slam::Point3d();\n        orientation_ptr->set_x(rot_vector(0));\n        orientation_ptr->set_y(rot_vector(1));\n        orientation_ptr->set_z(rot_vector(2));\n        minieye::slam::Point3f *linear_ptr = new minieye::slam::Point3f();\n        linear_ptr->set_x(linear_x);\n        linear_ptr->set_y(linear_y);\n        linear_ptr->set_z(linear_z);\n        minieye::slam::InsData rtk;\n        rtk.set_allocated_header(header_ptr);\n        rtk.set_allocated_pos_wgs84(pos_wgs84_ptr);\n        rtk.set_allocated_orientation(orientation_ptr);\n        rtk.set_allocated_enu_vel(linear_ptr);\n        auto sim_ptr = std::make_shared`<`SimData`<`minieye::slam::InsData`>``>`();\n        sim_ptr->data_type = MsgType::RTK;\n        sim_ptr->msg->CopyFrom(rtk);\n        sim_ptr->send_time = generate_time;\n        mtx_.lock();\n        rtk_deq_.emplace_back(sim_ptr);\n        mtx_.unlock();\n    }\n    std::cout << &amp;#39;parse rtk is finishing !!!&amp;#39; << std::endl;\n}\n\'> </span>'}]}, {'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">source/parse_imu.cpp</p><span class=\'hidden-code\' data-code=\'ParseImu::ParseImu(const std::string &amp;cfg_path){\n    imu_deq_.clear();\n    YAML::Node cfg = YAML::LoadFile(cfg_path);               // &amp;#39;./config/test.yaml&amp;#39;\n    std::string data_path = cfg[&amp;#39;path&amp;#39;].as`<`std::string`>`();\n    cache_ = cfg[&amp;#39;cache&amp;#39;].as`<`int`>`();\n    if (data_path.empty()){\n        return;\n    }\n    std::string imu_path = data_path + cfg[&amp;#39;imu_name&amp;#39;].as`<`std::string`>`();\n    thr_ = std::make_shared`<`std::thread`>`(&amp;ParseImu::Parse, this, imu_path);    // 也未执行啥\n}\n\'> </span>'}, {'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">source/parse_vehicle.cpp</p><span class=\'hidden-code\' data-code=\'ParseVehicle::ParseVehicle(const std::string &amp;cfg_path){\n    vehicle_deq_.clear();\n    YAML::Node cfg = YAML::LoadFile(cfg_path);\n    std::string data_path = cfg[&amp;#39;path&amp;#39;].as`<`std::string`>`();\n    cache_ = cfg[&amp;#39;cache&amp;#39;].as`<`int`>`();  \n    if (data_path.empty()){\n        return;\n    }\n    json_path_ = data_path + cfg[&amp;#39;vehicle_json_name&amp;#39;].as`<`std::string`>`();   // 20240328/seq_01/cve/20240328110647/parsed_results/vehicle_signal/bm.1.can2.CCAN.can.index.json\n    vehicle_path_ = data_path + cfg[&amp;#39;vehicle_name&amp;#39;].as`<`std::string`>`();     // 20240328/seq_01/cve/20240328110647/parsed_results/vehicle_signal/bm.1.can2.CCAN.can.pb.bin\n    thr_ = std::make_shared`<`std::thread`>`(&amp;ParseVehicle::Parse, this);\n}\n\'> </span>', 'children': [{'type': 'heading', 'depth': 5, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">source/parse_vehicle.cpp</p><span class=\'hidden-code\' data-code=\'void ParseVehicle::Parse(){\n    double gtc = 0.0;\n    double utc = 0.0;\n    std::cout << &amp;#39;Load vehicle json : &amp;#39; << json_path_  << std::endl << &amp;#39;Load vehicle bin : &amp;#39; << vehicle_path_ << std::endl;\n    char *pb_file_content = `textFileRead`((char *)vehicle_path_.c_str());\n    DynamicJsonDocument *doc = new DynamicJsonDocument(80240 * 100 * 100);\n    char *index_file_content = textFileRead((char *)json_path_.c_str());\n    deserializeJson(*doc, index_file_content);\n    JsonArray ja = (*doc)[&amp;#39;index&amp;#39;];\n    if (ja.size() == 0){\n        std::cout << &amp;#39;Load vehicle json failed : &amp;#39; << json_path_ << std::endl << &amp;#39;Load vehicle bin failed : &amp;#39;  << vehicle_path_ << std::endl;\n        return;\n    }\n    for (size_t i = 0; i < ja.size(); i++){\n        while (CheckCache()){\n            usleep(1e5);\n        }\n        \n        uint64_t timestamp = ja[i][0];\n        int32_t offset = ja[i][1];\n        int32_t length = ja[i][2];\n        std::shared_ptr`<`minieye::VehicleSignal`>` data_frame(new minieye::VehicleSignal());\n        // char *ptr=new char[length];\n        // memcpy(ptr,pb_file_content+offset,length);\n        bool rt = data_frame->ParseFromArray(pb_file_content + offset, length);\n        if (!rt){\n            std::cout << &amp;#39;Parse Json failed : &amp;#39; << json_path_ << &amp;#39; &amp;#39;  << vehicle_path_ << std::endl;\n            return;\n        }\n        gtc = data_frame->tick() * 1e-3;\n        utc = data_frame->timestamp() * 1e-3;\n        auto sim_ptr = std::make_shared`<`SimData`<`minieye::VehicleSignal`>``>`();\n        sim_ptr->data_type = MsgType::VS;\n        sim_ptr->msg->CopyFrom(*data_frame);\n        sim_ptr->send_time = utc;\n        mtx_.lock();\n        vehicle_deq_.emplace_back(sim_ptr);\n        mtx_.unlock();\n    }\n    // inject_start_tick=min(inject_start_tick,Vehicle_start_tick);\n    // inject_end_tick=max(inject_end_tick,Vehicle_end_tick);\n    free(pb_file_content);\n    delete doc;\n    std::cout << &amp;#39;parse vehicle is finishing !!!&amp;#39; << std::endl;\n}\n\'> </span>'}, {'type': 'heading', 'depth': 5, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">source/parse_vehicle.cpp</p><span class=\'hidden-code\' data-code=\'static char *textFileRead(char *filename){\n    FILE *pfile;\n    char *data;\n    pfile = fopen(filename, &amp;#39;r&amp;#39;);       // 0x555555b13c70 &amp;#39;/..../cve/20240328110647/parsed_results/vehicle_signal/bm.1.can2.CCAN.can.pb.bin&amp;#39;\n    if (pfile == NULL){\n        return NULL;\n    }\n    fseek(pfile, 0, SEEK_END);\n    int length = ftell(pfile);\n    data = (char *)malloc((length + 1) * sizeof(char));\n    rewind(pfile);\n    length = fread(data, 1, length, pfile);\n    // 注意：文件内容可能读出\\0，用strlen获取的长度可能不正确\n    data[length] = &amp;#39;\\0&amp;#39;;\n    fclose(pfile);\n    return data;\n}\n\'> </span>'}]}, {'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">source/parse_video.cpp</p><span class=\'hidden-code\' data-code=\'ParseVideo::ParseVideo(const std::string &amp;cfg_path){\n    video_deq_.clear();\n    YAML::Node cfg = YAML::LoadFile(cfg_path);\n    std::string data_path = cfg[&amp;#39;path&amp;#39;].as`<`std::string`>`();\n    cache_ = cfg[&amp;#39;cache&amp;#39;].as`<`int`>`();\n    if (data_path.empty()){\n        return;\n    }\n    log_path_ = data_path + cfg[&amp;#39;csv_name&amp;#39;].as`<`std::string`>`();\n    video_name_ = `SplitString`(cfg[&amp;#39;video_name&amp;#39;].as`<`std::string`>`(), &amp;#39;/&amp;#39;).back();\n    std::cout << &amp;#39;video_name_ : &amp;#39; << video_name_ << std::endl;\n    //std::string video_dir_path = data_path + cfg[&amp;#39;video_name&amp;#39;].as`<`std::string`>`() + &amp;#39;/&amp;#39;;\n    std::string video_dir_path = cfg[&amp;#39;video_name&amp;#39;].as`<`std::string`>`() + &amp;#39;/&amp;#39;;\n    video_path_map_ = GetOrderedFile(video_dir_path, &amp;#39;jpg&amp;#39;);\n    thr_ = std::make_shared`<`std::thread`>`(&amp;ParseVideo::Parse, this);\n}\n\'> </span>', 'children': [{'type': 'heading', 'depth': 5, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">inc/common.h</p><span class=\'hidden-code\' data-code=\'static std::deque`<`std::string`>` SplitString(const std::string &amp;str, const std::string &amp;part){\n    std::deque`<`std::string`>` resDeq;\n    if (&amp;#39;&amp;#39; == str){              // &amp;#39;/&amp;#39;\n        return resDeq;\n    }\n    std::string strs = str + part;\n    size_t pos = strs.find(part);\n    size_t size = strs.size();\n    while (pos != std::string::npos){\n        std::string substr = strs.substr(0, pos); //substr函数，获得子字符串\n        resDeq.push_back(substr);\n        strs = strs.substr(pos + 1, size);\n        pos = strs.find(part);\n    }\n    return resDeq;\n}\n\'> </span>'}]}]}]}]}]})</script><script src='https://study1994.github.io/study_html/npm/myjs/tooltip.js'></script>
</body>
</html>
