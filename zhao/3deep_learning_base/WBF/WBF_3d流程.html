<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>WBF_3d流程</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://study1994.github.io/study_html/npm/prism.css"><link rel="stylesheet" href="https://study1994.github.io/study_html/npm/markmap-toolbar@0.13.5/dist/style.css">
</head>
<body>
    <svg id="mindmap"></svg>
    <script src="https://study1994.github.io/study_html/npm/d3@6.7.0"></script>
    <script src="https://study1994.github.io/study_html/npm/markmap-view@0.13.5"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
    <script>
        (r => {
            setTimeout(r);
        })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{'type': 'root', 'depth': 0, 'content': '', 'children': [{'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">example_3d.py</p><font size="0"><pre class="language-python"><code class="language-python">def example_wbf_3d_2_models(iou_thr=0.55, draw_image=True):\n    boxes_list = [[[0.00, 0.51, 0.41, 0.81, 0.91, 0.78],[0.10, 0.31, 0.45, 0.71, 0.61, 0.85],[0.01, 0.32, 0.55, 0.83, 0.93, 0.95],[0.02, 0.53, 0.11, 0.11, 0.94, 0.55],[0.03, 0.24, 0.34, 0.12, 0.35, 0.67]],\n                  [[0.04, 0.56, 0.36, 0.84, 0.92, 0.82],[0.12, 0.33, 0.46, 0.72, 0.64, 0.75],[0.38, 0.66, 0.55, 0.79, 0.95, 0.90],[0.08, 0.49, 0.15, 0.21, 0.89, 0.67]]]\n    scores_list = [[0.9,0.8,0.2,0.4,0.7],[0.5,0.8,0.7,0.3]]\n    labels_list = [[1,0,1,0,0],[0,0,0,1]]\n    weights = [2, 1]\n    boxes, scores, labels = <span style=\'color: green;font-weight: bold;\'>weighted_boxes_fusion_3d</span>(boxes_list, scores_list, labels_list, weights=weights, iou_thr=iou_thr, skip_box_thr=0.0)\n    print(len(boxes))\n</code></pre></font>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">ensemble_boxes/ensemble_boxes_wbf_3d.py</p><font size="0"><pre class="language-python"><code class="language-python">def weighted_boxes_fusion_3d(boxes_list, scores_list, labels_list, weights=None, iou_thr=0.55, skip_box_thr=0.0, conf_type=\'avg\', allows_overflow=False):\n    weights = np.array(weights)                 <span style=\'color: red\'># array([2, 1])</span>\n    if conf_type not in [\'avg\', \'max\']:\n        conf_type = \'avg\'\n    filtered_boxes = <span style=\'color: green;font-weight: bold;\'>prefilter_boxes</span>(boxes_list, scores_list, labels_list, weights, skip_box_thr)   <span style=\'color: red\'># {1:np.shape=(3,8),0:np.shape=(6,8)}</span>\n    overall_boxes = []\n    for label in filtered_boxes:\n        boxes = filtered_boxes[label]        <span style=\'color: red\'># (3, 8), len(boxes)=3</span>\n        new_boxes = []\n        weighted_boxes = []\n        <span style=\'color: red\'># Clusterize boxes</span>\n        for j in range(0, len(boxes)):\n            index, best_iou = <span style=\'color: green;font-weight: bold;\'>find_matching_box</span>(weighted_boxes, boxes[j], iou_thr)\n            if index != -1:\n                new_boxes[index].append(boxes[j])\n                weighted_boxes[index] = <span style=\'color: green;font-weight: bold;\'>get_weighted_box</span>(new_boxes[index], conf_type)     <span style=\'color: red\'># conf_type=avg</span>\n            else:\n                new_boxes.append([boxes[j].copy()])\n                weighted_boxes.append(boxes[j].copy())\n        <span style=\'color: red\'># Rescale confidence based on number of models and boxes</span>\n        for i in range(len(new_boxes)):\n            if not allows_overflow:          <span style=\'color: red\'># False</span>\n                weighted_boxes[i][1] = weighted_boxes[i][1] * min(weights.sum(), len(new_boxes[i])) / weights.sum() <span style=\'color: red\'># 置信度重新计算</span>\n            else:\n                weighted_boxes[i][1] = weighted_boxes[i][1] * len(new_boxes[i]) / weights.sum()\n        overall_boxes.append(np.array(weighted_boxes))\n    overall_boxes = np.concatenate(overall_boxes, axis=0)\n    overall_boxes = overall_boxes[overall_boxes[:, 1].argsort()[::-1]]\n    boxes = overall_boxes[:, 2:]\n    scores = overall_boxes[:, 1]\n    labels = overall_boxes[:, 0]\n    return boxes, scores, labels\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">ensemble_boxes/ensemble_boxes_wbf_3d.py</p><font size="0"><pre class="language-python"><code class="language-python">def prefilter_boxes(boxes, scores, labels, weights, thr):\n    <span style=\'color: red\'># Create dict with boxes stored by its label</span>\n    new_boxes = dict()\n    for t in range(len(boxes)):\n        for j in range(len(boxes[t])):\n            score = scores[t][j]\n            if score < thr:\n                continue\n            label = int(labels[t][j])\n            box_part = boxes[t][j]\n            x1 = float(box_part[0])\n            y1 = float(box_part[1])\n            z1 = float(box_part[2])\n            x2 = float(box_part[3])\n            y2 = float(box_part[4])\n            z2 = float(box_part[5])\n            b = [int(label), float(score) * weights[t], x1, y1, z1, x2, y2, z2]\n            if label not in new_boxes:\n                new_boxes[label] = []\n            new_boxes[label].append(b)\n    <span style=\'color: red\'># Sort each list in dict by score and transform it to numpy array</span>\n    for k in new_boxes:   <span style=\'color: red\'># {1:[[1, 1.8, 0.0, 0.51, 0.41, 0.81, 0.91, 0.78], ..., [1, 0.3, 0.08, 0.49, 0.15, 0.21, 0.89, 0.67]]，0:[[0, 1.6, 0.1, 0.31, 0.45, 0.71, 0.61, 0.85], ..., [0, 0.8, 0.12, 0.33, 0.46, 0.72, 0.64, 0.75]}</span>\n        current_boxes = np.array(new_boxes[k])\n        new_boxes[k] = current_boxes[current_boxes[:, 1].argsort()[::-1]]     <span style=\'color: red\'># 按分数排序</span>\n    return new_boxes  <span style=\'color: red\'># {1:np.shape=(3,8),0:np.shape=(6,8)}</span>\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">j=0</p>for j in range(0, len(boxes))<br>', 'children': [{'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">ensemble_boxes/ensemble_boxes_wbf_3d.py</p><font size="0"><pre class="language-python"><code class="language-python">def find_matching_box(boxes_list, new_box, match_iou):  <span style=\'color: red\'># [],(8,),0.2</span>\n    best_iou = match_iou\n    best_index = -1\n    for i in range(len(boxes_list)):\n        box = boxes_list[i]\n        if box[0] != new_box[0]:\n            continue\n        iou = bb_intersection_over_union_3d(box[2:], new_box[2:])\n        if iou > best_iou:\n            best_index = i\n            best_iou = iou\n    return best_index, best_iou   <span style=\'color: red\'># -1,0.2</span>\n</code></pre></font>'}]}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">j=1</p><font size="0"><pre class="language-python"><code class="language-python">for j in range(0, len(boxes))\nif index != -1:\n    new_boxes[index].append(boxes[j])                                           <span style=\'color: red\'># [[(8,),(8,)]]</span>\n    weighted_boxes[index] = <span style=\'color: green;font-weight: bold;\'>get_weighted_box</span>(new_boxes[index], conf_type)     <span style=\'color: red\'># conf_type=avg</span>\n</code></pre></font>', 'children': [{'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">ensemble_boxes/ensemble_boxes_wbf_3d.py</p><font size="0"><pre class="language-python"><code class="language-python">def find_matching_box(boxes_list, new_box, match_iou):  <span style=\'color: red\'># [(8,)],(8,),0.2</span>\n    best_iou = match_iou\n    best_index = -1\n    for i in range(len(boxes_list)):                    <span style=\'color: red\'># 1</span>\n        box = boxes_list[i]                             <span style=\'color: red\'># (8,)</span>\n        if box[0] != new_box[0]:                        <span style=\'color: red\'># False     表面标签一样</span>\n            continue\n        iou = bb_intersection_over_union_3d(box[2:], new_box[2:])   <span style=\'color: red\'># 0.29874979704497484</span>\n        if iou > best_iou:\n            best_index = i\n            best_iou = iou\n    return best_index, best_iou   <span style=\'color: red\'># 0,0.29874979704497484</span>\n</code></pre></font>'}, {'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">ensemble_boxes/ensemble_boxes_wbf_3d.py</p><font size="0"><pre class="language-python"><code class="language-python">def get_weighted_box(boxes, conf_type=\'avg\'):      <span style=\'color: red\'># [(8,),(8,)],  \'avg\'</span>\n    box = np.zeros(8, dtype=np.float32)\n    conf = 0\n    conf_list = []\n    for b in boxes:                 <span style=\'color: red\'># [1.0, 1.8, 0.0, 0.51, 0.41, 0.81, 0.91, 0.78]  </span>\n        box[2:] += (b[1] * b[2:])   <span style=\'color: red\'># (x1,y1,z1,x2,y2,z2都乘以分数)并相加</span>\n        conf += b[1]                <span style=\'color: red\'># 总分数</span>\n        conf_list.append(b[1])      <span style=\'color: red\'># 每个分数组成list</span>\n    box[0] = boxes[0][0]            <span style=\'color: red\'># 标签</span>\n    if conf_type == \'avg\':\n        box[1] = conf / len(boxes)\n    elif conf_type == \'max\':\n        box[1] = np.array(conf_list).max()\n    box[2:] /= conf                <span style=\'color: red\'># 每个值按分数相乘，然后除以总分数</span>\n    return box                     <span style=\'color: red\'># [(8,)]</span>\n</code></pre></font>'}]}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">j=2</p>for j in range(0, len(boxes))<br>'}]}]})</script></body>
</html>
