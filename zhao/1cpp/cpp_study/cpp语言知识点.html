<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>cpp语言知识点</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 400vh;
}
</style>
<link rel="stylesheet" href="https://study1994.github.io/study_html/npm/prism.css"><link rel="stylesheet" href="https://study1994.github.io/study_html/npm/markmap-toolbar@0.13.5/dist/style.css">
</head>
<body>
    <svg id="mindmap"></svg>
    <script src="https://study1994.github.io/study_html/npm/d3@6.7.0"></script>
    <script src="https://study1994.github.io/study_html/npm/markmap-view@0.13.5"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
    <script>
        (r => {
            setTimeout(r);
        })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{'type': 'root', 'depth': 0, 'content': '', 'children': [{'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">00C_C++语言入门</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">C语言入门</p>', 'children': [{'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">一个C语言程序</p><font size="0"><pre class="language-cpp"><code class="language-cpp"># include <stdio.h>\nint main(){                 <span style=\'color: red\'>// 带括号的称为函数（Function）:函数就是一段可以重复使用的代码</span>\n    printf("C语言中文网");\n    system("pause");\n    return 0;\n}\n</code></pre></font>'}]}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">内置类型-常量变量</p>', 'children': [{'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">基本内置类型</p><font size="0"><pre class="language-cpp"><code class="language-cpp">`bool`布尔类型;`int`整型;`double`双精度浮点数;\nchar-字符;wchar_t-宽字符;char16_t-Unicode字符;char32_t-Unicode字符;short-短整型;\nlong-长整型;long long-长整型;float-单精度浮点数;long double-拓展精度浮点数;\n</code></pre></font>\n1字=4字节=32比特<br>', 'children': [{'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">C++修饰符类型</p><font size="0"><pre class="language-cpp"><code class="language-cpp"># include <iostream>\nusing namespace std;       <span style=\'color: red\'>// 这个程序演示了有符号整数和无符号整数之间的差别</span>\nint main(){\n   short int i;           <span style=\'color: red\'>// 有符号短整数  正数，负数或0</span>\n   short unsigned int j;  <span style=\'color: red\'>// 无符号短整数  就只能是正数</span>\n   j = 50000;\n   i = j;\n   cout << i << " " << j;  <span style=\'color: red\'>// -15536 50000 无符号短整数50,000 的位模式被解释为有符号短整数-15,536</span>\n   return 0;\n}\n</code></pre><p></font>\n<code>signed</code>、<code>unsigned</code>、<code>long</code> 和 <code>short</code> 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型<br></p>'}, {'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">带符号类型和无符号类型</p>\n<p><code>带符号</code>类型可以表示正数，负数或0，可以理解为带的符号就是正负号，<code>无符号</code>类型只能表示非负数，不要混用带符号类型和无符号类型<br></p>', 'children': [{'type': 'heading', 'depth': 5, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">枚举类型</p><font size="0"><pre class="language-cpp"><code class="language-cpp">enum color { red, green, blue } c;      <span style=\'color: red\'>// 枚举名为color，枚举变量c的类型为color</span>\nc = blue;                               <span style=\'color: red\'>// c被赋值为 "blue"</span>\nenum color1 { red, green=5, blue };     //red为0，green为5，blue为6\n</code></pre></font>'}]}, {'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">类型转换</p><font size="0"><pre class="language-cpp"><code class="language-cpp">bool b = 42;                     <span style=\'color: red\'>// b为真，除非b=0，其他均为真</span>\nint i = b;                       <span style=\'color: red\'>// i=1,因为b是true，对应的int就是1，注意原来的42早就木有了</span>\nint a = 3.66;                    <span style=\'color: red\'>// a=3,注意不是四舍五入，而是直接舍弃</span>\ndouble c = a;                    <span style=\'color: red\'>// c=3.0</span>\nunsigned char m1 = -1;           <span style=\'color: red\'>// 8比特unsigned char表示0-255区间，总数为256=2^8  -1对256去模为255((-1+256)%256)</span>\nsigned char m2 = 256;            <span style=\'color: red\'>// 超过它表示范围的数无定义</span>\n<span style=\'color: red\'>// 3.5，当碰到+/-等运算符，都会把小范围的数转成大范围的,int->double来保证不损失精度</span>\nint a = 1;\ndouble b = 2.5;\ncout << a+b << endl;\n</code></pre></font>'}]}, {'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">常量</p>', 'children': [{'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">整数常量</p><font size="0"><pre class="language-cpp"><code class="language-cpp">85         <span style=\'color: red\'>// 十进制</span>\n0213       <span style=\'color: red\'>// 八进制        0x 或 0X 表示十六进制，0表示八进制</span>\n0x4b       <span style=\'color: red\'>// 十六进制 </span>\n30         <span style=\'color: red\'>// 整数 </span>\n30u        <span style=\'color: red\'>// 无符号整数     U 表示无符号整数（unsigned），L 表示长整数（long）</span>\n30l        <span style=\'color: red\'>// 长整数 </span>\n30ul       <span style=\'color: red\'>// 无符号长整数</span>\n</code></pre></font>'}, {'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">浮点常量</p><font size="0"><pre class="language-cpp"><code class="language-cpp">3.14159       <span style=\'color: red\'>// 合法的 </span>\n314159E-5L    <span style=\'color: red\'>// 合法的 </span>\n510E          <span style=\'color: red\'>// 非法的：不完整的指数</span>\n210f          <span style=\'color: red\'>// 非法的：没有小数或指数</span>\n.e55          <span style=\'color: red\'>// 非法的：缺少整数或分数</span>\n</code></pre></font>'}, {'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">布尔常量</p>\n<p><code>true</code>值代表真。<code>false</code>值代表假<br></p>'}, {'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">字符常量</p><font size="0"><pre class="language-cpp"><code class="language-cpp"><span style=\'color: red\'>// 宽字符常量（例如 L\'x\'），此时它必须存储在 wchar_t 类型的变量中</span>\n<span style=\'color: red\'>// 窄字符常量（例如 \'x\'），此时它可以存储在 char 类型的简单变量中</span>\n\\n  换行符\n\\r  回车\n</code></pre></font>'}, {'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">#define预处理器</p><font size="0"><pre class="language-cpp"><code class="language-cpp">#include <iostream>\nusing namespace std;\n#define LENGTH 10\n#define NEWLINE \'\\n\'\nint main(){\n    cout << LENGTH;\n    cout << NEWLINE;\n    return 0;\n}\n</code></pre></font>'}, {'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">C++ 数学运算与随机数`#include <cmath>`</p><font size="0"><pre class="language-cpp"><code class="language-cpp">#include <iostream>\n#include <cmath>\nusing namespace std;\nint main (){\n   <span style=\'color: red\'>// 数字定义</span>\n   short  s = 10;\n   int    i = -1000;\n   long   l = 100000;\n   float  f = 230.47;\n   double d = 200.374;\n   <span style=\'color: red\'>// 数学运算</span>\n   cout << "sin(d) :" << sin(d) << endl;\n   cout << "abs(i)  :" << abs(i) << endl;\n   cout << "floor(d) :" << floor(d) << endl;\n   cout << "sqrt(f) :" << sqrt(f) << endl;\n   cout << "pow( d, 2) :" << pow(d, 2) << endl;\n   return 0;\n}\n</code></pre><p></font>\n（3）<code>&lt;cmath&gt;srand()time()rand()</code><br>\n（4）<code>extern</code>（5）名字的作用域用大括号来区分<br></p>'}]}]}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=17b5e0d3-4e3a-4df7-ae2b-379a162fcf93&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">04：运算符基础</a><br>\n<code>sizeof</code>运算符<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=8eb37df7-2994-4f2d-bee1-1c50f3f1e648&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">05：语句</a></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=a8cc62cc-e294-49e4-ae73-58f9c2c47947&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">06：函数</a><br>\n函数重载；const形参；<code>const_cast</code>；内联函数和<code>constexpr</code>函数<br>\n（1） 函数的返回类型不能是数组类型（因为数组不能被拷贝）或函数类型（2）自动对象、局部静态对象（3）使用引用避免拷贝<br>\n（4）使用数组名时会将其转换为指针-&gt;数组形参<code>void f(const int*);void f(const int[]);void f(const int[5]);</code><br>\n（5）<code>数组引用</code>形参<code>void f(int (&amp;arr)[10]);</code>（6）可变参数<code>void errorMsg(initializer_list il)</code>;<code>void errorMsg(int a, initializer_list il)</code>;<br>\n（7）const_cast使用；（8）内联函数和constexpr函数<br></p>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">01从C到C++</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=1d64e5a8-c9f5-402d-920c-ff1738e5c2f4&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">01：结构体和对象</a><br>\n类和对象概念；结构体；<br>\n（1）使用 class 时，类中的成员默认都是<code>private</code>属性的；而使用struct时，结构体中的成员默认都是 public 属性的。<br>\n（2）class 继承默认是 private 继承，而 struct 继承默认是 public 继承（3）class 可以使用模板，而struct不能。<br>\n（4）结构体作为参数<code>void display(struct Student stu)</code>（5）<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=87cd4e20-d7b7-4194-9423-dd3c2e6fffdb&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">02：环境/编译运行</a><br>\ngcc；g++；<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=5d172ad2-d985-488b-84ba-ed6c8358e714&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">03：输入输出(cin和cout)</a><br>\n<code>scanf("%d",&amp;a)</code>/<code>printf("%d\\n", c)</code>；<code>cin&lt;&lt;(istream类的对象)</code>/<code>cout&gt;&gt;(ostream类的对象)</code>；<br>\n（1）连续输入默认以<code>空格</code>分离 <code>cin&gt;&gt;x&gt;&gt;y</code>;<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=3e52401d-efee-4643-b9b0-73f6106a03ff&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">04：头文件与命名空间(std)</a><br>\n（1）namespace name{//variables, functions, classes}  （2）C++头文件命名<code>iostream.h</code>变成了<code>iostream</code>，在命名空间<code>std</code>中<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=2fb71f33-6849-47ad-8f19-896b1ef4ef6a&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">05：变量定义位置与bool</a><br>\ncpp不强制必须在函数开头定义所有变量；C++ 新增<code>bool类型</code>,占用1个字节长度,使用cout输出0,1而不是true和false；<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=4526b0ae-c472-4234-81b2-28a0aa50c41d&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">06：const详解</a><br>\n（1）只是了解使用<code>const int n = 10; int *p = (int*)&amp;n; *p = 99;</code>为啥强制类型转换。<br>\n（2）<code>const比*离变量近</code>则修饰指针，比<code>*远</code>则修饰变量不能变：<code>const int *p1</code>; <code>int const *p2</code>;<code>int * const p3;</code><br>\n（2）const变量的可见范围仅限于当前源文件，c语言可以使用<code>extern int n</code>;，C++则要包含头文件。<br>\nconst定义的常量是有类型的，编译器会进行<code>类型检查</code>，相对来说比#define更安全。#define 定义的常量仅仅是字符串的替换，不会进行类型检查<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=1211738b-01e2-4e12-89e7-689420c6cff4&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">07：new和delete运算符</a><br>\n（1）代码（2）记住malloc函数返回值类型是<code>void*</code>，能隐式转换成其他指针类型<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=f581f23d-b2a5-40f9-911b-c72f5ace53b3&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">08：inline内联函数与宏</a><br>\n（1）函数之前需要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；<br>\n（2）内联函数消除<code>函数调用的时空开销</code>，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，<br>\n那么编译后的程序体积也将会变得很大，所以一般只将那些短小的、频繁调用的函数声明为内联函数。<br>\n（4）宏仅仅是字符串替换，不是按值传递【内联函数把整体当做形参】<code>#define SQ(y) y*y-》用SQ(n)换成SQ(n+1)-》sq = n+1*n+1;</code><br>\n（5）发生函数调用时，编译器会先对实参进行计算，再将计算的结果传递给形参，并且函数执行完毕后会得到一个值，而不是得到一个表达式，<br>\n这和简单的字符串替换相比省去了很多麻烦，所以在编写C++代码时我推荐<code>使用内联函数来替换带参数的宏</code>。<br>\n（6）和宏一样，内联函数可以定义在头文件中(不用加 static 关键字)，并且头文件<code>被多次#include</code>后也不会引发重复定义错误。<br>\n这一点和非内联函数不同，非内联函数是<code>禁止定义在头文件中</code>的，它所在的头文件被多次#include后会引发重复定义错误。<br>\n（7）内联函数在编译时会将函数调用处用函数体替换，编译完成后函数就不存在了，所以在链接时不会引发重复定义错误。<br>\n这一点和宏很像，宏在预处理时被展开，编译时就不存在了。从这个角度讲，内联函数更像是编译期间的宏。<br>\n（8）编译器会忽略函数声明处的<code>inline 关键字</code>，或者内联函数声明不需要inline。（9）将函数定义和函数声明分开，但不适合内联函数，否则能够正常编译，<br>\n但在链接时会出错。编译期间会用它来替换函数调用处，编译完成后函数就不存在了，<br>\n链接器在将多个目标文件（.o或.obj文件）合并成一个可执行文件时找不到 func() 函数的定义，所以会产生链接错误。<br>\n在多文件编程时，我建议将内联函数的定义直接放在头文件中，并且禁用内联函数的声明<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=fbf76b91-bc08-487f-b522-3d8de9daa704&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">09：函数默认参数</a><br>\n（1）C语言有四种作用域，分别是函数原型作用域、局部作用域（函数作用域）、块作用域、文件作用域（全局作用域）<br>\n（2）func() 的定义和声明位于同一个源文件，它们的作用域也都是整个源文件，这样就导致在同一个文件作用域中指定了两次默认参数，编译错误<br>\n（3）多次声明同一函数，第一次声明时为 c 指定了默认值，第二次声明时为 b 指定了默认值；#include <algorithm><br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=9deadd92-89cd-4a72-bfb5-b5e011a5e26f&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">10：函数重载详解</a><br>\n参数列表必须不同(<code>个数</code>不同、<code>类型</code>不同、<code>参数排列顺序</code>不同)等<br></p>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">02类和对象</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=2b961724-85c3-49d4-a28a-e3be1a65d5b1&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">01：类的定义和对象的创建</a><br>\n对象指针；对象数组；<br>\n在类定义的最后有一个分号;<code>/Student LiLei;/Student allStu[100];</code>/对象通过.访问；对象指针通过-&gt;访问；<br>\n(1)对象stu在栈上分配内存[栈内存是程序自动管理的]，需要使用&amp;获取它的地址;<code>Student stu;Student *pStu = &amp;stu;</code><br>\n(2)在堆上使用new关键字创建<code>Student *pStu = new Student;</code>记得delete掉不再使用的对象。(3)对象数组初始化[看代码]。<br>\n(4)this是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=f97408d5-540f-4e6e-b37b-ab17f3aff9b6&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">02：类的成员变量和函数</a><br>\n在类外定义,类型 类名::函数名{}=void Student::say(){}。在类体中定义的成员函数会自动成为内联函数【建议在类内定义】;<br>\n在内外成内联函数需要inline void Student::say(){}。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=b0108c53-aafa-418f-b21a-9cbab87b6583&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">03：类成员的访问权限及封装</a><br>\n类的内部，无论成员被声明为 public、protected 还是 private，都是可以互相访问的。在类的外部（定义类的代码之外），<br>\n只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=a7c188be-659c-4e9f-8a7e-54465a164cff&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">04：对象的内存模型</a><br>\n对象所占用的内存仅仅包含了成员变量。对象的大小只受成员变量的影响，和成员函数没有关系。<br>\n对象所占用的存储空间的大小等于各成员变量所占用的存储空间的大小之和（如果不考虑成员变量对齐问题的话）。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=2f4b577f-774d-420f-80c2-dce84d04551a&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">05：构造函数</a> 构造函数重载；初始化成员；const成员变量；<br>\n(1)调用函数会隐式的传递函数常指针<code>Demo * const p【Demo为类名】</code>构造函数：类名(参数);Student(){}。<br>\n(2)初始化const成员变量必须使用初始化列表来初始化<code>VLA::VLA(int len): m_len(len){m_arr = new int[len];}</code><br>\n(2）定义类时，如果一个构造函数都不写，则编译器自动生成默认（无参）构造函数和复制构造函数。如果编写了构造函数，则编译器不自动生成默认构造函数。<br>\n一个类不一定会有默认构造函数，但一定会有复制构造函数。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=ac65bc09-1b0b-4de4-848f-8176b1b69366&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">06：析构函数</a><br>\n~类名();<code>VLA *parr = new VLA(n);</code>会调用构造函数，delete parr;会调用析构函数。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=f88c9717-c248-461f-befd-c1ed250d95b0&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">07：成员对象和封闭类详解</a><br>\n一个类的成员变量如果是另一个类的对象，就称之为“成员对象”。包含成员对象的类叫封闭类（enclosed class）。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=b21c3299-af35-43dd-addc-37b1fd5d45d7&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">08：static静态成员</a><br>\n（1）静态成员变量实现多个对象共享数据，需外部初始化 类型 类名::静态变量名=0; int Student::m_total = 0;；通过对象/类访问，不占用对象内存；<br>\n（2）静态成员函数没有 this 指针，只能访问静态成员变量和静态成员函数，可以通过类来直接调用，编译器不会为它增加形参 this，<br>\n它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数 类名::静态成员函数;<code>int total = Student::getTotal();</code>；<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=0c9edbde-62d6-41d7-8c7a-cac9ca6b4d8d&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">09：const成员变量/函数/对象</a><br>\n（1）为了保护数据，const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，在声明和定义的时候在函数头部的结尾加上const 关键字，<code>char *getname() const;</code>；<br>\n（2）常对象<code>const Student stu("小明", 15, 90.6);/const Student *pstu = new Student("李磊", 16, 80.5);</code>只能调用类的 const 成员<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=eaba3e4a-249c-4d9f-a5b3-570656fa19bb&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">10：友元函数和友元类</a><br>\n（1）在类中声明前加friend 关键字<code>friend void show(Student *pstu);</code>，借助友元可以访问与其有好友关系的类中的私有成员。<br>\n（2）在Address类中将Student类中的成员函数show()声明为友元函数【show() 就可以访问 Address 类的 private 成员变量】<code>friend void Student::show(Address *addr);</code>。<br>\n（3）将Student类声明为Address类的友元类【有的编译器也可以不写 class 关键字，不过为了增强兼容性还是建议写上】<code>friend class Student;</code>。<br>\n（4）友元的关系是单向且不能传递<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=e6c27685-c7e5-4ca8-b35c-50ab9f7f9a85&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">11：类也是一种作用域</a><br>\n普通的成员只能通过对象（可以是对象本身，也可以是对象指针或对象引用）来访问，静态成员既可以通过对象访问，又可以通过类访问，而 typedef 定义的类型【typedef int INT;】只能通过类来访问。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=72b376a0-51c6-45f3-b05c-12d4795c70b2&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">12：拷贝构造函数(复制构造函数)</a></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=87b2c4bf-d0fb-463e-8b8d-d2ea408fc803&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">13：继承关系类间的强制转化</a></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=f17c9320-3ba8-4577-9241-46b2483e3648&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">20：类和对象总结</a></p>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">03C++引用</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=31974fb1-e6a8-40f3-9111-c96fb49dff63&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">01：C++引用入门</a><br>\nint &amp;r = a;传递指针<code>void swap2(int *p1, int *p2)</code>引用传参<code>void swap3(int &amp;r1, int &amp;r2);</code>。引用作为函数返回值<code>int &amp;plus10(int &amp;r){}</code><br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=40895c74-75a3-452f-912e-e49c576453be&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">02：引用本质</a><br>\na的引用-<code>int &amp;r = a;</code>a的地址-<code>int *r = &amp;a;</code>p为指针-<code>int *p = arr;</code>指针指向的值<code>*p</code>。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=de88a429-7f3d-4885-aadf-fbbd35a3d359&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">03：引用不能绑定到临时数据</a><br>\n（1）指针只能指向内存，用&amp;来获取地址。表达式所产生的临时结果会被放到寄存器中，用&amp;获取它们的地址都是错误的。<code>int *p1 = &amp;(100);</code>这种获取常量表达式也是错误的<br>\n（2）int、double、bool、char 等较小的临时数据会放在寄存器中，<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=86e85227-911e-4c40-a5ed-e0242544833f&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">04：编译器会为const引用建临时变量</a><br>\nbool isOdd(const int &amp;n)常引用可以这样传参isOdd(a + 9);。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=ec930340-05d4-408c-bd47-99ae39f67223&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">05：const引用与转换类型</a><br>\n给引用添加 const 限定后，不但可以将引用绑定到临时数据，还可以将引用绑定到类型相近的数据，临时变量。<br></p>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">04继承与派生</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=8716f501-b9e2-423c-9785-368b8e6c9295&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">01：继承和派生简明教程</a><br>\nclass 派生类名:［继承方式］ 基类名{派生类新增加的成员}; <code>class People{}；class Student: public People{};</code><br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=9f66ae11-2d5d-41a3-9eca-3ccea8300121&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">02：三种继承方式</a><br>\n在派生类中使用using，可以改变基类成员在派生类中的访问权限，<code>using People::m_name;using People::show;(show为函数名)</code>。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=34ca37b6-d0df-4eff-9e3c-89f2fb5e8bba&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">03：继承时的名字遮蔽问题</a><br>\n派生类和基类中成员重名造成遮蔽而不构成重载,仍要使用基类函数要加上类名和域解析符,<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=138a8b69-857f-48c2-ada7-9968249085ff&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">04：类继承时的作用域嵌套</a></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=0f75f001-134b-4cec-aeec-5963865d212f&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">05：继承时的对象内存模型</a><br>\n派生类的内存模型是基类成员变量和新增成员变量的总和，而所有成员函数仍然存储在另外一个区域-代码区，由所有对象共享。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=b4cfe752-db2a-4620-9cbe-a4c058330a15&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">06：基类和派生类的构造函数</a><br>\n类的构造函数不能被继承，将基类构造函数的调用放在参数初始化表后面，<code>Student::Student(char *name, int age, float score): m_score(score), People(name, age){ }</code>。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=d10b2fbf-4da6-45aa-b305-4e2dcd9fa9ad&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">07：基类和派生类的析构函数</a><br>\n析构函数也不能被继承，在派生类的析构函数中不用显式地调用基类的析构函数。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=e47b2f0d-6ecb-4099-ba85-20cc88dfabc6&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">08：多继承（多重继承）详解</a></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=6251da88-c372-4e70-aa51-39690fae35f4&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">09：多继承时的对象内存模型</a><br>\n基类对象的排列顺序和继承时声明的顺序相。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=6a05a9e5-9d44-4035-9ba6-91be6c842e9b&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">10：借助指针突破访问权限的限制</a><br>\n<code>int b = *(int*)( (int)p + sizeof(int) );</code>。p 是对象 obj 的指针，(int)p将指针转换为一个整数，这样才能进行加法运算；sizeof(int)用来计算 m_b 的偏移；<br>\n<code>(int)p + sizeof(int)</code>得到的就是 m_b 的地址，不过因为此时是int类型，所以还需要强制转换为<code>int *</code>类型；开头的<code>*</code>用来获取地址上的数据。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=8f5fb1f7-1e5a-4605-b3a0-a86f2e8f5bec&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">11：虚继承和虚基类详解</a><br>\n虚继承在派生类 D 中就只保留了一份成员变量 <code>m_a；</code>,<code>class C: virtual public A{};</code>。iostream 从 istream 和 ostream 直接继承而来，<br>\n而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类，是典型的菱形继承。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=96fc0884-d9a5-4517-9e63-9d79af1836c8&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">12：虚继承时的构造函数</a><br>\n须由最终的派生类 D 来初始化虚基类 A，直接派生类 B 和 C 对 A 的构造函数的调用是无效的。不管各个构造函数出现的顺序如何，<br>\n编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数；<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=6d6b17a8-d031-4e28-95ab-6c602081b742&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">13：虚继承下的内存模型</a><br>\n虚基类的子对象始终位于派生类对象的最后<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=5c8f2947-76fd-47a0-ab43-e0fc59cdd7b2&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">14：将派生类赋值给基类(向上转型)</a><br>\n（1）赋值的本质是将现有的数据写入已分配好的内存中，对象的内存只包含了成员变量，所以对象之间的赋值是成员变量的赋值。<code>A a(10);/B b(66, 99);/a = b;</code>。<br>\n（2）与对象变量之间的赋值不同的是，对象指针之间的赋值并没有拷贝对象的成员，也没有修改对象本身的数据，仅仅是改变了指针的指向。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=6cc4d7ec-5e4b-4089-aa30-f4d6744bee56&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">15：派生类指针赋值基类指针实质</a></p>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">05C++多态与虚函数</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=49c6a378-6159-4cfe-8a37-8f2cb5a860c7&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">01：多态和虚函数入门</a><br>\n（1）当基类指针 p 指向派生类 Teacher 的对象时，虽然使用了 Teacher 的成员变量，但是却没有使用它的成员函数。<br>\n通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。<br>\n2）基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。<br>\n<code>People *p = new People("王志刚", 23);p -&gt; display();p = new Teacher("赵宏佳", 45, 8200);p -&gt; display();</code>。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=a2661a0b-8054-4cb6-b8a6-a34ee742dca7&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">02：虚函数以及构成多态的条件</a><br>\n<code>p -&gt; func();</code>调用的是派生类的虚函数，构成了多态】<code>p -&gt; func(10);</code>调用的是基类的虚函数，因为派生类中没有函数覆盖它】<br>\n<code>p -&gt; func("http://c.biancheng.net");</code>通过基类的指针只能访问从基类继承过去的成员，不能访问派生类新增的成员】<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=5567661b-7963-4d04-926a-3a912e311312&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">03：虚析构函数的必要性</a><br>\n派生类的指针delete pa;在执行派生类的析构函数的过程中，又会调用基类的析构函数，而基类的指针delete pd;<br>\n只会调用基类的析构函数。基类为虚析构函数时无论那个指针都会调用所有的析构函数。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=4f162cf7-483c-4522-be82-fd509f1bb130&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">04：纯虚函数和抽象类</a><br>\nvirtual 返回值类型 函数名 (函数参数) = 0;<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=755cb4d7-5655-4047-8990-2e0295c46e05&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">05：虚函数表-多态的实现机制</a><br>\n（1）类包含了虚函数，在创建该类的对象时就会额外地增加一个数组，数组中的每一个元素都是虚函数的入口地址。<br>\n数组和对象是分开存储的，为了将对象和数组关联起来，编译器还要在对象中安插一个指针，指向数组的起始位置。<br>\n这里的数组就是虚函数表（Virtual function table），简写为vtable。<br>\n（2）左半部分是对象占用的内存，右半部分是虚函数表 vtable。在对象的开头位置有一个指针 vfptr，指向虚函数表，并且这个指针始终位于对象的开头位置。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=cf977e8a-850f-4435-9193-9cfc4ef9d057&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">07：RTTI机制</a>【===】</p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=1d35e8d8-200e-4205-b4dd-568dd56dab8e&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">08：静态绑定和动态绑定</a>【===】</p>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">06运算符重载</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=87229b41-5a10-4f60-ae97-2a5d9858a92d&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">01：运算符重载基础</a><br>\n（1）运算符重载：返回值类型 operator 运算符名称 (形参表列){},将operator 运算符名称这一部分看做函数名。<br>\n（2）运算符重载函数不是 complex 类的成员函数，但是却用到了 complex 类的 private 成员变量，所以必须在 complex 类中将该函数声明为友元函数。<br>\n<code>friend complex operator+(const complex &amp;A, const complex &amp;B)</code>;<code>complex operator+(const complex &amp;A, const complex &amp;B)</code>;<br>\n（3）重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边.<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=e8170c7e-d4f6-4d57-83d9-36a350a9f77e&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">02：重载运算符的形式</a><br>\n（1）转换构造函数，将 double 转换为 Complex，再调用重载过的 + 进行计算【看图】（2）以全局函数的形式重载 +以便对称处理数据。<br>\nC++ 规定，箭头运算符-&gt;、下标运算符[ ]、函数调用运算符( )、赋值运算符=只能以成员函数的形式重载。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=bbc589ce-69da-43b8-bdc2-0f96b71d06a2&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">03：重载&gt;&gt;和&lt;&lt;(输入输出运算符)</a><br>\n重载输入运算符&gt;&gt;；重载输出运算符&lt;&lt;【看懂代码】<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=45be860c-3ec8-446d-a305-649a46662528&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">04：重载[]和++/--(自增和自减)</a>  放弃</p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=f7a2c95b-75f6-45e0-9122-12ceec1d7b03&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">05：重载new/delete和().md</a> 放弃</p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=0419ff22-8f7f-4d3c-9c83-c7ed28acedc3&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">06：运算符重载注意事项</a></p>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">07模板</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=c770a821-aba4-4c8e-9c57-53bcbaec9d33&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">01：函数模板与类模板</a><br>\n（1）typename关键字也可以使用class关键字替代，<code>void Swap(float *a, float *b)；template&lt;typename T&gt; void Swap(T *a, T *b){}；</code><br>\n【template <typename 类型参数1 , typename 类型参数2 , ...> 返回值类型 函数名(形参列表){}】<br>\n（2）声明-<code>template&lt;typename 类型参数1 , typename 类型参数2 , …&gt; class 类名{}；</code><br>\n定义-<code>template&lt;typename 类型参数1 , typename 类型参数2 , …&gt; 返回值类型 类名&lt;类型参数1 , 类型参数2, ...&gt;::函数名(形参列表){}；</code><br>\n创建对象-<code>Point&lt;int, int&gt; p1(10, 20);+Point&lt;float, float&gt; *p1 = new Point&lt;float, float&gt;(10.6, 109.3);</code>。<br>\n（3）不能将模板的声明和定义分散到多个文件中」的根本原因是：模板的实例化是由编译器完成的，而不是由链接器完成的，这可能会导致在链接期间找不到对应的实例。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=3f341ff4-6d84-4106-b041-24601cfcfd38&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">02：模板编程及函数模板的重载</a><br>\n交换两个数组<code>template&lt;typename T&gt; void Swap(T a[], T b[], int len){}</code>。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=a10da144-2dc1-463c-923d-37ebb2b693c3&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">03：函数模板的实参推断</a><br>\n显式指明实参可以正常类型转换：<code>template&lt;typename T&gt; void func(T a, T b);</code>// 它的具体调用形式如下：<br>\nfunc(10, 23.5); //Error；func<float>(20, 93.7); //Correct【已经显式地指明了 T 的类型为 float，<br>\n编译器不会再为「T 的类型到底是 int 还是 double」而纠结了，所以可以从容地使用正常的类型转换了】<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=ae32393a-48f9-4a17-986c-be3ff771c2da&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">04：模板的显式具体化</a></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=8c6bd992-2742-4386-9bcd-91d751e9731f&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">05：模板中的非类型参数</a></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=c33d1df4-bb49-4477-863e-95312c600b35&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">06：模板的实例化</a></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=85076b1e-d358-4df6-8403-839e32bffcc4&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">07：类模板与继承详解</a></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=8b2a09fc-c1cc-4bed-9b7a-11c458c22652&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">08：类模板与友元详解</a></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=2bbc31a9-dc3f-4e75-9a11-7c52dc538d8c&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">09：类模板中的静态成员</a></p>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">08C++异常</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=f3a8e788-b4d4-4c15-b02e-1079de31e427&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">01：异常处理-try/catch入门</a><br>\n（1）string 类at() 会检查下标是否越界，[]不会。<code>try{}catch(exceptionType variable){}；throw "Unknown Exception";</code>。<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=3d512807-0876-4b8a-9df1-820bec0c6690&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">02：异常类型及多级catch匹配</a><br>\n（1）抛出异常时，会创建一个 exception 类或其子类的对象。（2）<code>try{}catch(int){}catch(char *){}</code><br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=699cb278-ff9c-48be-adb3-c74659553cbf&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">03：throw(抛出异常)详解</a><br>\n（1）Array 类实现了动态数组。throw 用作异常规范<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="wiz://open_document?guid=0d91d409-6931-47f4-8f6d-8fa81b3e0daf&amp;kbguid=&amp;private_kbguid=cd3e7135-af02-4dd9-9793-363a9bbc2769">04：exception类-标准异常的基类</a><br>\n<code>exception 类</code><br></p>'}]}]})</script></body>
</html>
