<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>cuda_pointpillars_demo</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://study1994.github.io/study_html/npm/prism.css"><link rel="stylesheet" href="https://study1994.github.io/study_html/npm/markmap-toolbar@0.13.5/dist/style.css">
</head>
<body>
    <svg id="mindmap"></svg>
    <script src="https://study1994.github.io/study_html/npm/d3@6.7.0"></script>
    <script src="https://study1994.github.io/study_html/npm/markmap-view@0.13.5"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
    <script>
        (r => {
            setTimeout(r);
        })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{'type': 'root', 'depth': 0, 'content': '', 'children': [{'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">main.cpp</p><font size="0"><pre class="language-cpp"><code class="language-cpp">int main(int argc, const char **argv){\n  <span style=\'color: green;font-weight: bold;\'>Getinfo</span>();\n  cudaEvent_t start, stop;           <span style=\'color: red\'>// 0x7fffde347792,0x7fffffffd800</span>\n  float elapsedTime = 0.0f;\n  cudaStream_t stream = NULL;        <span style=\'color: red\'>// 0x0</span>\n  checkCudaErrors(cudaEventCreate(&start));\n  checkCudaErrors(cudaEventCreate(&stop));\n  checkCudaErrors(cudaStreamCreate(&stream));\n  Params <span style=\'color: green;font-weight: bold;\'>params_</span>;\n  std::vector<<span style=\'color: green;font-weight: bold;\'>Bndbox</span>> nms_pred;\n  nms_pred.reserve(100);              <span style=\'color: red\'>// 在需要对大量数据进行处理的时候就要使用reserve主动分配内存以提升程序执行效率</span>\n  PointPillar <span style=\'color: green;font-weight: bold;\'>pointpillar</span>(Model_File, stream);\n  for (int i = 0; i < 10; i++){\n    std::string dataFile = Data_File;      <span style=\'color: red\'>// "../data/"</span>\n    std::stringstream ss;\n    ss<< i;\n    int n_zero = 6;\n    std::string _str = ss.str();           <span style=\'color: red\'>// "0"</span>\n    std::string index_str = std::string(n_zero - _str.length(), \'0\') + _str;\n    dataFile += index_str;\n    dataFile +=".bin";                    <span style=\'color: red\'>// "../data/000000.bin"</span>\n    <span style=\'color: red\'>// load points cloud</span>\n    unsigned int length = 0;\n    void *data = NULL;\n    std::shared_ptr<char> buffer((char *)data, std::default_delete<char[]>());\n    <span style=\'color: green;font-weight: bold;\'>loadData</span>(dataFile.data(), &data, &length);\n    buffer.reset((char *)data);\n    float* points = (float*)buffer.get();\n    size_t points_size = length/sizeof(float)/4;    <span style=\'color: red\'>// 20285</span>\n    float *points_data = nullptr;\n    unsigned int points_data_size = points_size * 4 * sizeof(float);\n    checkCudaErrors(cudaMallocManaged((void **)&points_data, points_data_size));\n    checkCudaErrors(cudaMemcpy(points_data, points, points_data_size, cudaMemcpyDefault));\n    checkCudaErrors(cudaDeviceSynchronize());\n    cudaEventRecord(start, stream);\n    <span style=\'color: green;font-weight: bold;\'>pointpillar.doinfer</span>(points_data, points_size, nms_pred);\n    cudaEventRecord(stop, stream);\n    cudaEventSynchronize(stop);\n    cudaEventElapsedTime(&elapsedTime, start, stop);\n    checkCudaErrors(cudaFree(points_data));\n    std::string save_file_name = Save_Dir + index_str + ".txt";\n    SaveBoxPred(nms_pred, save_file_name);\n    nms_pred.clear();\n  }\n  checkCudaErrors(cudaEventDestroy(start));\n  checkCudaErrors(cudaEventDestroy(stop));\n  checkCudaErrors(cudaStreamDestroy(stream));\n  return 0;\n}\n</code></pre></font>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">main.cpp</p><font size="0"><pre class="language-cpp"><code class="language-cpp">void Getinfo(void){\n  cudaDeviceProp prop;       //\n  int count = 0;\n  cudaGetDeviceCount(&count);     <span style=\'color: red\'>// count=8  &count=0x7fffffffd4b8</span>\n  printf("\\nGPU has cuda devices: %d\\n", count);      <span style=\'color: red\'>// GPU has cuda devices: 8</span>\n  for (int i = 0; i < count; ++i) {\n    cudaGetDeviceProperties(&prop, i);\n    printf("----device id: %d info----\\n", i);\n    printf("  GPU : %s \\n", prop.name);                                <span style=\'color: red\'>// GPU : NVIDIA GeForce RTX 3090</span>\n    printf("  Capbility: %d.%d\\n", prop.major, prop.minor);            <span style=\'color: red\'>// Capbility: 8.6</span>\n    printf("  Global memory: %luMB\\n", prop.totalGlobalMem >> 20);     <span style=\'color: red\'>// Global memory: 24268MB</span>\n    printf("  Const memory: %luKB\\n", prop.totalConstMem  >> 10);      <span style=\'color: red\'>// Const memory: 64KB</span>\n    printf("  SM in a block: %luKB\\n", prop.sharedMemPerBlock >> 10);  <span style=\'color: red\'>// SM in a block: 48KB</span>\n    printf("  warp size: %d\\n", prop.warpSize);                        <span style=\'color: red\'>// warp size: 32</span>\n    printf("  threads in a block: %d\\n", prop.maxThreadsPerBlock);     <span style=\'color: red\'>// threads in a block: 1024</span>\n    printf("  block dim: (%d,%d,%d)\\n", prop.maxThreadsDim[0], prop.maxThreadsDim[1], prop.maxThreadsDim[2]);  <span style=\'color: red\'>// block dim: (1024,1024,64)</span>\n    printf("  grid dim: (%d,%d,%d)\\n", prop.maxGridSize[0], prop.maxGridSize[1], prop.maxGridSize[2]);         <span style=\'color: red\'>// grid dim: (2147483647,65535,65535)</span>\n  }\n  printf("\\n");\n}\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">include/params.h</p><font size="0"><pre class="language-cpp"><code class="language-cpp">const int MAX_VOXELS = 40000;\nclass Params{\n  public:\n    static const int num_classes = 3;\n    const char *class_name [num_classes] = { "Car","Pedestrian","Cyclist",};\n    const float min_x_range = 0.0;\n    const float max_x_range = 69.12;\n    const float min_y_range = -39.68;\n    const float max_y_range = 39.68;\n    const float min_z_range = -3.0;\n    const float max_z_range = 1.0;\n    <span style=\'color: red\'>// the size of a pillar</span>\n    const float pillar_x_size = 0.16;\n    const float pillar_y_size = 0.16;\n    const float pillar_z_size = 4.0;\n    const int max_num_points_per_pillar = 32;\n    const int num_point_values = 4;\n    <span style=\'color: red\'>// the number of feature maps for pillar scatter</span>\n    const int num_feature_scatter = 64;\n    const float dir_offset = 0.78539;\n    const float dir_limit_offset = 0.0;\n    <span style=\'color: red\'>// the num of direction classes(bins)</span>\n    const int num_dir_bins = 2;\n    <span style=\'color: red\'>// anchors decode by (x, y, z, dir)</span>\n    static const int num_anchors = num_classes * 2;\n    static const int len_per_anchor = 4;\n    const float anchors[num_anchors * len_per_anchor] = {\n      3.9,1.6,1.56,0.0,\n      3.9,1.6,1.56,1.57,\n      0.8,0.6,1.73,0.0,\n      0.8,0.6,1.73,1.57,\n      1.76,0.6,1.73,0.0,\n      1.76,0.6,1.73,1.57,\n      };\n    const float anchor_bottom_heights[num_classes] = {-1.78,-0.6,-0.6,};\n    <span style=\'color: red\'>// the score threshold for classification</span>\n    const float score_thresh = 0.1;\n    const float nms_thresh = 0.01;\n    const int max_num_pillars = MAX_VOXELS;       <span style=\'color: red\'>// 40000</span>\n    const int pillarPoints_bev = max_num_points_per_pillar * max_num_pillars;  <span style=\'color: red\'>// 32*40000</span>\n    <span style=\'color: red\'>// the detected boxes result decode by (x, y, z, w, l, h, yaw)</span>\n    const int num_box_values = 7;\n    <span style=\'color: red\'>// the input size of the 2D backbone network</span>\n    const int grid_x_size = (max_x_range - min_x_range) / pillar_x_size;   <span style=\'color: red\'>// 432</span>\n    const int grid_y_size = (max_y_range - min_y_range) / pillar_y_size;   <span style=\'color: red\'>// 496</span>\n    const int grid_z_size = (max_z_range - min_z_range) / pillar_z_size;   <span style=\'color: red\'>// 1</span>\n    <span style=\'color: red\'>// the output size of the 2D backbone network</span>\n    const int feature_x_size = grid_x_size / 2;\n    const int feature_y_size = grid_y_size / 2;\n    Params() {};\n};\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">include/postprocess.h</p><font size="0"><pre class="language-cpp"><code class="language-cpp">struct Bndbox {float x;float y;float z;float w;float l;float h;float rt;int id;float score;\n    Bndbox(){};\n    Bndbox(float x_, float y_, float z_, float w_, float l_, float h_, float rt_, int id_, float score_)\n        : x(x_), y(y_), z(z_), w(w_), l(l_), h(h_), rt(rt_), id(id_), score(score_) {}\n};\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">src/pointpillar.cpp</p><font size="0"><pre class="language-cpp"><code class="language-cpp">PointPillar::PointPillar(std::string modelFile, cudaStream_t stream):stream_(stream){  <span style=\'color: red\'>// "../model/pointpillar.onnx";  0x5555567d9fd0  后面初始化变量：cudaStream_t PointPillar::stream_=stream</span>\n  checkCudaErrors(cudaEventCreate(&start_));       \n  checkCudaErrors(cudaEventCreate(&stop_));\n  pre_.reset(new <span style=\'color: green;font-weight: bold;\'>PreProcessCuda</span>(stream_));   <span style=\'color: red\'>// 设置变量值 std::shared_ptr<PreProcessCuda> pre_ = new PreProcessCuda(stream_)</span>\n  trt_.reset(new <span style=\'color: green;font-weight: bold;\'>TRT</span>(modelFile, stream_));\n  post_.reset(new <span style=\'color: green;font-weight: bold;\'>PostProcessCuda</span>(stream_));\n  //point cloud to voxels\n  voxel_features_size_ = MAX_VOXELS * params_.max_num_points_per_pillar * 4 * sizeof(float);      <span style=\'color: red\'>// 40000*32*4*4</span>\n  voxel_num_size_ = MAX_VOXELS * sizeof(unsigned int);                                            <span style=\'color: red\'>// sizeof(unsigned int)=4</span>\n  voxel_idxs_size_ = MAX_VOXELS* 4 * sizeof(unsigned int);\n  checkCudaErrors(cudaMallocManaged((void **)&voxel_features_, voxel_features_size_));\n  checkCudaErrors(cudaMallocManaged((void **)&voxel_num_, voxel_num_size_));\n  checkCudaErrors(cudaMallocManaged((void **)&voxel_idxs_, voxel_idxs_size_));\n  checkCudaErrors(cudaMemsetAsync(voxel_features_, 0, voxel_features_size_, stream_));\n  checkCudaErrors(cudaMemsetAsync(voxel_num_, 0, voxel_num_size_, stream_));\n  checkCudaErrors(cudaMemsetAsync(voxel_idxs_, 0, voxel_idxs_size_, stream_));\n  //TRT-input\n  features_input_size_ = MAX_VOXELS * params_.max_num_points_per_pillar * 10 * sizeof(float);    <span style=\'color: red\'>// 40000x32x10</span>\n  checkCudaErrors(cudaMallocManaged((void **)&features_input_, features_input_size_));\n  checkCudaErrors(cudaMallocManaged((void **)&params_input_, sizeof(unsigned int)));\n  checkCudaErrors(cudaMemsetAsync(features_input_, 0, features_input_size_, stream_));\n  checkCudaErrors(cudaMemsetAsync(params_input_, 0, sizeof(unsigned int), stream_));\n  //output of TRT -- input of post-process\n  cls_size_ = params_.feature_x_size * params_.feature_y_size * params_.num_classes * params_.num_anchors * sizeof(float);      <span style=\'color: red\'>// 216x248x3x6</span>\n  box_size_ = params_.feature_x_size * params_.feature_y_size * params_.num_box_values * params_.num_anchors * sizeof(float);   <span style=\'color: red\'>// 216x248x7x6</span>\n  dir_cls_size_ = params_.feature_x_size * params_.feature_y_size * params_.num_dir_bins * params_.num_anchors * sizeof(float); <span style=\'color: red\'>// 216x248x2x6</span>\n  checkCudaErrors(cudaMallocManaged((void **)&cls_output_, cls_size_));\n  checkCudaErrors(cudaMallocManaged((void **)&box_output_, box_size_));\n  checkCudaErrors(cudaMallocManaged((void **)&dir_cls_output_, dir_cls_size_));\n  //output of post-process\n  bndbox_size_ = (params_.feature_x_size * params_.feature_y_size * params_.num_anchors * 9 + 1) * sizeof(float);     <span style=\'color: red\'>// 216x248x6x9+1</span>\n  checkCudaErrors(cudaMallocManaged((void **)&bndbox_output_, bndbox_size_));\n  res_.reserve(100);\n  return;\n}\n</code></pre></font>', 'children': [{'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">include/preprocess.h</p><font size="0"><pre class="language-cpp"><code class="language-cpp">class PreProcessCuda {\n  private:\n    Params params_;\n    unsigned int *mask_;\n    float *voxels_;\n    int *voxelsList_;\n    float *params_cuda_;\n    cudaStream_t stream_ = 0;\n  public:\n    PreProcessCuda(cudaStream_t stream_ = 0);\n    ~PreProcessCuda();\n    //points cloud -> voxels (BEV) -> feature*4 \n    int generateVoxels(float *points, size_t points_size, unsigned int *pillar_num, float *voxel_features, unsigned int *voxel_num, unsigned int *voxel_idxs);\n    //feature*4 -> feature * 10 \n    int generateFeatures(float* voxel_features, unsigned int *voxel_num, unsigned int* voxel_idxs, unsigned int *params, float* features);\n};\n</code></pre></font>', 'children': [{'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<font size="0"><pre class="language-cpp"><code class="language-cpp">TRT::TRT(std::string modelFile, cudaStream_t stream):stream_(stream){\n  std::string modelCache = modelFile + ".cache";        <span style=\'color: red\'>// "../model/pointpillar.onnx.cache"</span>\n  std::fstream trtCache(modelCache, std::ifstream::in);\n  checkCudaErrors(cudaEventCreate(&start_));\n  checkCudaErrors(cudaEventCreate(&stop_));\n  if (!trtCache.is_open())            <span style=\'color: red\'>// False</span>\n  {.....} else {\n\tstd::cout << "load TRT cache."<<std::endl;\n    char *data;\n    unsigned int length;\n    <span style=\'color: red\'>// get length of file:</span>\n    trtCache.seekg(0, trtCache.end);\n    length = trtCache.tellg();           <span style=\'color: red\'>// 20242750</span>\n    trtCache.seekg(0, trtCache.beg);\n    data = (char *)malloc(length);\n    if (data == NULL ) {\n       std::cout << "Can\'t malloc data.\\n";\n       exit(-1);\n    }\n    trtCache.read(data, length);\n    <span style=\'color: red\'>// create context</span>\n    auto runtime = nvinfer1::createInferRuntime(gLogger_);\n    if (runtime == nullptr) {\t  std::cout << "load TRT cache0."<<std::endl;\n        std::cerr << ": runtime null!" << std::endl;\n        exit(-1);\n    }\n    //plugin_ = nvonnxparser::createPluginFactory(gLogger_);\n    engine_ = (runtime->deserializeCudaEngine(data, length, 0));\n    if (engine_ == nullptr) {\n        std::cerr << ": engine null!" << std::endl;\n        exit(-1);\n    }\n    free(data);\n    trtCache.close();\n  }\n  context_ = engine_->createExecutionContext();   <span style=\'color: red\'>// runtime->engine_->context_</span>\n  return;\n}\n</code></pre></font>'}]}, {'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">src/postprocess.cpp</p><font size="0"><pre class="language-cpp"><code class="language-cpp">PostProcessCuda::PostProcessCuda(cudaStream_t stream){\n  stream_ = stream;\n  checkCudaErrors(cudaMalloc((void **)&anchors_, params_.num_anchors * params_.len_per_anchor * sizeof(float)));      <span style=\'color: red\'>// 6,4,sizeof(float)=4</span>\n  checkCudaErrors(cudaMalloc((void **)&anchor_bottom_heights_, params_.num_classes * sizeof(float)));\n  checkCudaErrors(cudaMalloc((void **)&object_counter_, sizeof(int)));\n  checkCudaErrors(cudaMemcpyAsync(anchors_, params_.anchors,params_.num_anchors * params_.len_per_anchor * sizeof(float), cudaMemcpyDefault, stream_));\n  checkCudaErrors(cudaMemcpyAsync(anchor_bottom_heights_, params_.anchor_bottom_heights,params_.num_classes * sizeof(float), cudaMemcpyDefault, stream_));\n  checkCudaErrors(cudaMemsetAsync(object_counter_, 0, sizeof(int), stream_));\n  return;\n}\n</code></pre></font>'}]}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">main.cpp</p><font size="0"><pre class="language-cpp"><code class="language-cpp">int loadData(const char *file, void **data, unsigned int *length){\n  std::fstream dataFile(file, std::ifstream::in);\n  if (!dataFile.is_open()){\n\t  std::cout << "Can\'t open files: "<< file<<std::endl;\n\t  return -1;\n  }\n  //get length of file:\n  unsigned int len = 0;\n  dataFile.seekg (0, dataFile.end);\n  len = dataFile.tellg();\n  dataFile.seekg (0, dataFile.beg);\n  //allocate memory:\n  char *buffer = new char[len];\n  if(buffer==NULL) {\n\t  std::cout << "Can\'t malloc buffer."<<std::endl;\n      dataFile.close();\n\t  exit(-1);\n  }\n  //read data as a block:\n  dataFile.read(buffer, len);\n  dataFile.close();\n  *data = (void*)buffer;\n  *length = len;       <span style=\'color: red\'>// 324560</span>\n  return 0;  \n}\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">src/pointpillar.cpp</p>'}]}]})</script></body>
</html>
