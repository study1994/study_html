<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>tracking</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
.hidden-code {
  display: none !important;
}
</style>
<link rel="stylesheet" href="https://study1994.github.io/study_html/npm/mycss/style.css">
</head>
<body>
    <svg id="mindmap"></svg>
    <script src="https://study1994.github.io/study_html/npm/myjs/d3@6.7.0.js"></script>
    <script src="https://study1994.github.io/study_html/npm/myjs/markmap-view@0.13.5.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
    <script>
        (r => {
            setTimeout(r);
        })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{'type': 'root', 'depth': 0, 'content': '', 'children': [{'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/tools/run_track.py</p><span class=\'hidden-code\' data-code=\'def main():\n    dataset, dataloader = build_dataloader(\n        dataset_cfg=cfg.DATA_CONFIG,\n        data_path=args.data_path,           &amp;#39;./output/det_model_cfgs/centerpoint_1sweep/default/eval/epoch_30/val/result.pkl&amp;#39;  检测结果\n        log_time=log_time,\n        batch_size=args.batch_size,\n        workers=args.workers,\n        split=args.split,\n        logger=logger\n    )\n\'> </span>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/datasets/__init__.py</p><span class=\'hidden-code\' data-code=\'def build_dataloader(dataset_cfg, log_time, data_path, batch_size, workers, split, logger, root_path=None):\n    dataset = `__all__[dataset_cfg.DATASET]`(dataset_cfg=dataset_cfg,data_path=data_path,split=split,root_path=root_path,log_time=log_time,logger=logger)          # WaymoTrackDataset\n    # init as spawn mode\n    torch.multiprocessing.set_start_method(&amp;#39;spawn&amp;#39;)\n    dataloader = DataLoader(\n        dataset, batch_size=batch_size, pin_memory=True, num_workers=workers,\n        shuffle=False, collate_fn=dataset.collate_batch, drop_last=False, timeout=0\n    )\n    return dataset, dataloader\n\'> </span>', 'children': [{'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/datasets/waymo_dataset.py</p><span class=\'hidden-code\' data-code=\'class WaymoTrackDataset(DatasetTemplate):\n    def __init__(self, dataset_cfg, data_path, log_time, split, root_path=None, logger=None):\n        super().__init__(dataset_cfg, data_path, split, root_path, logger)\n        self.`load_paths`()\n        self.`init_infos`()\n\'> </span>', 'children': [{'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/datasets/waymo_dataset.py</p><span class=\'hidden-code\' data-code=\'class WaymoTrackDataset(DatasetTemplate):\n    def load_paths(self):\n        self.track_module_path = defaultdict(dict)\n        # set the desitation path of tracking result\n        track_path = os.path.join(self.root_path, &amp;#39;tracking&amp;#39;)       # &amp;#39;../../data/waymo/tracking&amp;#39;\n        self.track_module_path[&amp;#39;tracking&amp;#39;] = os.path.join(track_path, &amp;#39;-&amp;#39;.join([&amp;#39;tracking&amp;#39;, self.split, self.logtime]))  # ../../data/waymo/tracking/tracking-test-20231020-110032\n        self.track_module_path[&amp;#39;det_drop&amp;#39;] = os.path.join(track_path, &amp;#39;-&amp;#39;.join([&amp;#39;drop&amp;#39;, self.split, self.logtime]))      # &amp;#39;../../data/waymo/tracking/drop-test-20231020-110032&amp;#39;\n        # set the path of detection prediction results\n        self.track_module_path[&amp;#39;detection&amp;#39;] = self.det_path                              # detection/output/det_model_cfgs/centerpoint_1sweep/default/eval/epoch_30/val/result.pkl\n        # set the path of ground-truth infos\n        self.gt_path = os.path.join(self.root_path, &amp;#39;waymo_infos_%s.pkl&amp;#39; % self.split)   # &amp;#39;../../data/waymo/waymo_infos_test.pkl&amp;#39;  \n\'> </span>'}, {'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/datasets/waymo_dataset.py</p><span class=\'hidden-code\' data-code=\'class WaymoTrackDataset(DatasetTemplate):\n    def init_infos(self):\n        with open(self.track_module_path[&amp;#39;detection&amp;#39;], &amp;#39;rb&amp;#39;) as f:\n            raw_det = pickle.load(f)                  # [{&amp;#39;name&amp;#39;:(67,), &amp;#39;score&amp;#39;:(67,), &amp;#39;boxes_lidar&amp;#39;:(67,7), &amp;#39;sequence_name&amp;#39;:&amp;#39;10017090168044687777_6380_000_6400_000&amp;#39;, &amp;#39;frame_id&amp;#39;:0, &amp;#39;pose&amp;#39;:(4, 4)},...]\n        if isinstance(raw_det, list):\n            det_info = sequence_list_to_dict(raw_det) # {&amp;#39;10017090168044687777_6380_000_6400_000&amp;#39;:{&amp;#39;0&amp;#39;:{&amp;#39;name&amp;#39;:(67,), &amp;#39;score&amp;#39;:(67,), &amp;#39;boxes_lidar&amp;#39;:(67,7), &amp;#39;sequence_name&amp;#39;:&amp;#39;10017090168044687777_6380_000_6400_000&amp;#39;, &amp;#39;frame_id&amp;#39;:0, &amp;#39;pose&amp;#39;:(4, 4)},&amp;#39;1&amp;#39;:{},...}}\n        elif isinstance(raw_det, dict):\n            det_info = raw_det\n        self.seq_name_list = list(det_info.keys())[:]   # [&amp;#39;10017090168044687777_6380_000_6400_000&amp;#39;,..]\n        self.seq_det_infos = [det_info[seq_n] for seq_n in self.seq_name_list]  # [{&amp;#39;0&amp;#39;:{&amp;#39;name&amp;#39;:(67,), &amp;#39;score&amp;#39;:(67,), &amp;#39;boxes_lidar&amp;#39;:(67,7), &amp;#39;sequence_name&amp;#39;:&amp;#39;10017090168044687777_6380_000_6400_000&amp;#39;, &amp;#39;frame_id&amp;#39;:0, &amp;#39;pose&amp;#39;:(4, 4)},&amp;#39;1&amp;#39;:{},...},{}]\n        if self.assign_mode:                            # False                 \n            with open(self.gt_path, &amp;#39;rb&amp;#39;) as f:\n                raw_gt_infos = pickle.load(f)\n            gt_infos = sequence_list_to_dict(raw_gt_infos)\n            if len(gt_infos.keys()) != len(self.seq_name_list):\n                raise ValueError(&amp;#39;Ground-truth infomation loading falied.&amp;#39;)\n            self.gt_infos = [gt_infos[seq_n] for seq_n in self.seq_name_list]\n\'> </span>'}]}]}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/tools/run_track.py</p><span class=\'hidden-code\' data-code=\'def main():\n    `run_model`(\n        model=model, \n        dataloader=dataloader,\n        dataset=dataset,\n        workers=args.workers,\n        cfgs=cfg,\n        logger=logger,\n    )\n\'> </span>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/models/__init__.py</p><span class=\'hidden-code\' data-code=\'def run_model(model, dataloader, dataset, workers, cfgs=None, logger=None):\n    if dataset.assign_mode:\n        from detzero_track.models.tracking_modules import target_assign\n        assigner = partial(target_assign.assign_track_target, iou_thresholds=cfgs.REFINING.IOU_THRESHOLDS)\n        assign_data = dict()\n    track_data = dict()\n    drop_data = dict()\n    total_iter = len(dataloader)           # 3\n    pbar = tqdm(dataloader, total=total_iter, ascii=True, ncols=140)\n    for idx, (seq_names, data_dicts) in `enumerate(pbar)`:\n        model_outputs = multi_processing(function=`model.forward`,data_dict=data_dicts[&amp;#39;detection&amp;#39;], workers=workers)     # detzero_track.models.detzero_tracker.DetZeroTracker\n        track_data.update(dict(zip(seq_names, model_outputs)))\n        if dataset.assign_mode:\n            input_data = list(zip(data_dicts[&amp;#39;detection&amp;#39;], model_outputs, data_dicts[&amp;#39;gt&amp;#39;]))\n            refine_outputs = multi_processing(assigner, input_data, workers)\n            assign_data.update(dict(zip(seq_names, refine_outputs)))\n        drop_data.update(dict(zip(seq_names, data_dicts[&amp;#39;det_drop&amp;#39;])))\n    track_path = dataset.get_track_path()                # &amp;#39;../../data/waymo/tracking/tracking-test-20231024-144920.pkl&amp;#39;\n    with open(track_path, &amp;#39;wb&amp;#39;) as f:\n        if dataset.assign_mode:\n            pickle.dump(assign_data, f)\n        else:\n            pickle.dump(track_data, f)\n    drop_path = dataset.get_drop_path()                 # &amp;#39;../../data/waymo/tracking/drop-test-20231024-144920.pkl&amp;#39;\n    with open(drop_path, &amp;#39;wb&amp;#39;) as f:\n        pickle.dump(drop_data, f)\n\'> </span>', 'children': [{'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/datasets/waymo_dataset.py</p><span class=\'hidden-code\' data-code=\'class WaymoTrackDataset(DatasetTemplate):\n    def __getitem__(self, idx):\n        seq_name = self.seq_name_list[idx]          # &amp;#39;10017090168044687777_6380_000_6400_000&amp;#39;\n        det_infos = self.seq_det_infos[idx]         # {&amp;#39;0&amp;#39;:{&amp;#39;name&amp;#39;:(67,), &amp;#39;score&amp;#39;:(67,), &amp;#39;boxes_lidar&amp;#39;:(67,7), &amp;#39;sequence_name&amp;#39;:&amp;#39;10017090168044687777_6380_000_6400_000&amp;#39;, &amp;#39;frame_id&amp;#39;:0, &amp;#39;pose&amp;#39;:(4, 4)},&amp;#39;1&amp;#39;:{},...}\n        # detzero_track.datasets.data_processor.DataProcessor   heading_process+overlap_box_filter+transform_to_global\n        det_data, drop_data = self.data_processor.`forward`(data_dict=det_infos)\n        data_dict = {&amp;#39;detection&amp;#39;: det_data, &amp;#39;det_drop&amp;#39;: drop_data}\n        if self.assign_mode:\n            data_dict.update({&amp;#39;gt&amp;#39;: self.gt_infos[idx]})\n        return seq_name, data_dict\n\'> </span>', 'children': [{'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/datasets/data_processor.py</p><span class=\'hidden-code\' data-code=\'class DataProcessor(object):\n    def forward(self, data_dict):\n        processed_data = dict()\n        remove_data = dict()\n        sample_idx_list = sorted(list(data_dict.keys()), key=int)\n        for sample_idx in sample_idx_list:\n            curr_data = data_dict[sample_idx]\n            for cur_processor in self.data_processor_queue:\n                curr_data = `cur_processor`(data_dict=curr_data)  # heading_process+overlap_box_filter+transform_to_global\n                if isinstance(curr_data, tuple):\n                    remove_data[sample_idx] = curr_data[1]\n                    curr_data = curr_data[0] \n            processed_data[sample_idx] = curr_data\n        return processed_data, remove_data\n\'> </span>', 'children': [{'type': 'heading', 'depth': 5, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/datasets/data_processor.py</p><span class=\'hidden-code\' data-code=\'class DataProcessor(object):\n    def heading_process(self, data_dict=None, config=None):\n        if data_dict is None:\n            return partial(self.heading_process, config=config)\n        if data_dict.get(&amp;#39;boxes_lidar&amp;#39;, None) is not None:\n            heading = data_dict[&amp;#39;boxes_lidar&amp;#39;][:, 6] \n            data_dict[&amp;#39;boxes_lidar&amp;#39;][:, 6] = yaw_filter(heading)        # filter the heading into -pi ~ pi\n        return data_dict\n\'> </span>'}, {'type': 'heading', 'depth': 5, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/datasets/data_processor.py</p><span class=\'hidden-code\' data-code=\'class DataProcessor(object):\n    def overlap_box_filter(self, data_dict=None, config=None):         # (67,)\n        # process the ovelap boxes from detection data name_index\n        return data_dict, remove_data_dict                             # (22,) + (45,)\n\'> </span>'}, {'type': 'heading', 'depth': 5, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/datasets/data_processor.py</p><span class=\'hidden-code\' data-code=\'class DataProcessor(object):\n    def transform_to_global(self, data_dict=None, config=None):\n        if data_dict.get(&amp;#39;pose&amp;#39;, None) is not None:\n            pose = data_dict[&amp;#39;pose&amp;#39;]                                 # (4, 4)\n            boxes_lidar = data_dict[&amp;#39;boxes_lidar&amp;#39;]                   # (22, 7)\n            boxes_global = `transform_boxes3d`(boxes_lidar, pose)\n            data_dict[&amp;#39;boxes_global&amp;#39;] = boxes_global\n        return data_dict\n\'> </span>', 'children': [{'type': 'heading', 'depth': 6, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/utils/transform_utils.py</p><span class=\'hidden-code\' data-code=\'def transform_boxes3d(boxes, pose, inverse=False):\n    center = boxes[:, :3]\n    center = np.concatenate([center, np.ones((center.shape[0], 1))], axis=-1)  # (22, 4)\n    if inverse:                                                                # False\n        pose = get_inverse_transform_mat(pose)\n    center = center @ pose.T                                                   # (22, 4)\n    heading = yaw_filter(boxes[:, [6]] + np.arctan2(pose[1, 0], pose[0, 0]))\n    return np.concatenate([center[:, :3], boxes[:, 3:6], heading], axis=-1)\n\'> </span>'}]}]}]}, {'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/models/detzero_tracker.py</p><span class=\'hidden-code\' data-code=\'class DetZeroTracker():\n    def forward(self, data_dict):\n        for module in self.module_list:     # [detzero_track.models.tracking_modules.track_manager.TrackManager, detzero_track.models.tracking_modules.post_process.PostProcessor]\n            data_dict = module.`forward`(data_dict=data_dict)\n        return data_dict\n\'> </span>', 'children': [{'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/models/tracking_modules/track_manager.py</p><span class=\'hidden-code\' data-code=\'class TrackManager():\n    def forward(self, data_dict):\n        frame_list = sorted(list(data_dict.keys()), key=int)   # [&amp;#39;0&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;,....] 长度198，有198个序列\n        tracks = list()\n        tk_result = dict()\n        tk_id_cnt = self.init_track_id                         # 0\n        \n        for _, frm_id in enumerate(frame_list):\n            # execute tracking module frame by frame\n            frm_tk_data, tracks, tk_id_cnt = self.`online_track_module`(frm_id, data_dict[frm_id], tracks, tk_id_cnt)\n            # transfer the tracking result from frame-level  to object-level structure \n            for key, val in frm_tk_data.items():\n                if key not in tk_result.keys():\n                    tk_result[key] = defaultdict(list)\n                for sub_key, sub_val in val.items():\n                    tk_result[key][sub_key].append(sub_val)\n                tk_result[key][&amp;#39;pose&amp;#39;].append(data_dict[frm_id][&amp;#39;pose&amp;#39;])\n        for tk_id in tk_result.keys():\n            for key in tk_result[tk_id].keys():\n                tk_result[tk_id][key] = np.array(tk_result[tk_id][key])\n        # execute the reverse-order tracking stage\n        if self.modules_dicts[&amp;#39;reverse_tracking_config&amp;#39;].enable:\n            frm_tracks = dict()\n            reverse_tracks = list()\n            keys = [&amp;#39;boxes_global&amp;#39;, &amp;#39;name&amp;#39;, &amp;#39;score&amp;#39;, &amp;#39;sample_idx&amp;#39;,&amp;#39;hit&amp;#39;, &amp;#39;num_points&amp;#39;, &amp;#39;obj_ids&amp;#39;]\n            # transfer the tracking result to frame-level strutcure\n            for tk_id in tk_result.keys():\n                sample_idx = tk_result[tk_id][&amp;#39;sample_idx&amp;#39;]\n                for i, sa_idx in enumerate(sample_idx):\n                    if sa_idx not in frm_tracks.keys():\n                        frm_tracks[sa_idx] = defaultdict(list)\n                    frm_tracks[sa_idx][&amp;#39;start&amp;#39;].append(1 if i == 0 else 0)\n                    for key in keys:\n                        frm_tracks[sa_idx][key].append(tk_result[tk_id][key][i])\n            for key, items in frm_tracks.items():\n                for k, v in items.items():\n                    items[k] = np.array(v)\n            for idx, frm_id in enumerate(frame_list[::-1]):\n                frm_tk_data, reverse_tracks = self.`reverse_tracking_module`(frm_id, data_dict[frm_id], frm_tracks[frm_id], reverse_tracks)\n                for key, val in frm_tk_data.items():\n                    for sub_key, sub_val in val.items():\n                        tk_result[key][sub_key] = np.insert(tk_result[key][sub_key], 0, sub_val, axis=0)\n                    tk_result[key][&amp;#39;pose&amp;#39;] = np.insert(tk_result[key][&amp;#39;pose&amp;#39;], 0, data_dict[frm_id][&amp;#39;pose&amp;#39;], axis=0)\n        return tk_result\n\'> </span>', 'children': [{'type': 'heading', 'depth': 5, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/models/tracking_modules/track_manager.py</p><span class=\'hidden-code\' data-code=\'class TrackManager():\n    def online_track_module(self, frame_id, det_data, tracks, track_id_count):\n        track_data = self.`predict_tracks`(frame_id, tracks)\n        da_stage = (self.modules_dicts[&amp;#39;data_association_config&amp;#39;].stage.NAME == &amp;#39;one_stage&amp;#39;)  # False\n        if not da_stage and &amp;#39;num_points&amp;#39; not in det_data.keys():\n            det_data[&amp;#39;num_points&amp;#39;] = np.zeros_like(det_data[&amp;#39;score&amp;#39;])                         # (22,)\n        # detzero_track.models.tracking_modules.data_association.data_association.associate_det_to_tracks\n        matched, track_unmatch, det_unmatch, matched_stage = self.`modules_dicts[&amp;#39;data_association_module&amp;#39;]`(det_data, track_data)           \n        det_boxes = det_data[&amp;#39;boxes_global&amp;#39;]       # (22, 7)\n        det_name = det_data[&amp;#39;name&amp;#39;]                # (22, )  [&amp;#39;Vehicle&amp;#39;, ...]\n        for match_idx, match in enumerate(matched):   \n            tk_idx, det_idx = match\n            # 根据匹配结果将检测结果分配到匹配的tk_id\n            tracks[tk_idx].update(det_boxes[det_idx],det_name[det_idx],det_data[&amp;#39;score&amp;#39;][det_idx],det_data[&amp;#39;num_points&amp;#39;][det_idx] if not da_stage else 0,two_stage=matched_stage[match_idx])\n        for _, det_idx in enumerate(det_unmatch):   # 检测的结果  detzero_track.models.tracking_modules.kalman_filter.kalman_filter.KalmanFilter   初始化多个KalmanFilter(BaseKalmanFilter)\n            tracks.append(self.`modules_dicts[&amp;#39;filter_module&amp;#39;]`(bbox=det_boxes[det_idx],name=det_name[det_idx], score=det_data[&amp;#39;score&amp;#39;][det_idx],frame_id=frame_id,track_id=track_id_count,num_points=det_data[&amp;#39;num_points&amp;#39;][det_idx] if not da_stage else 0))\n            track_id_count += 1\n        if self.modules_dicts[&amp;#39;track_merge_config&amp;#39;][&amp;#39;enable&amp;#39;]:   # True\n            tracks = self.`overlap_track_merge`(tracks)\n        track_output_data = dict()\n        filter_cfg = self.modules_dicts[&amp;#39;filter_config&amp;#39;]        # {&amp;#39;name&amp;#39;: &amp;#39;KalmanFilter&amp;#39;, &amp;#39;x_dim&amp;#39;: 5, &amp;#39;z_dim&amp;#39;: 3, &amp;#39;q&amp;#39;: [5, 15], &amp;#39;p&amp;#39;: [50, 1000], &amp;#39;r&amp;#39;: 0.1, &amp;#39;delta_t&amp;#39;: 0.1}\n        track_age_cfg = self.modules_dicts[&amp;#39;track_age_config&amp;#39;]  # {&amp;#39;birth_age&amp;#39;: 1, &amp;#39;death_age&amp;#39;: -1}\n        for track in tracks:\n            if filter_cfg[&amp;#39;name&amp;#39;] == &amp;#39;AB3DMOT&amp;#39;:\n                if (track.hits `>`= track_age_cfg.birth_age or int(frame_id) `<` track_age_cfg.birth_age) and track.miss `<` track_age_cfg.death_age:\n                    track_output_data.update(copy.deepcopy(track.info()))\n            else:\n                track_output_data.update(copy.deepcopy(track.info()))\n        tracks_idx = len(tracks)\n        for track in reversed(tracks):\n            tracks_idx -= 1\n            if track.miss >= track_age_cfg.death_age and  (track_age_cfg.death_age != -1):\n                tracks.pop(tracks_idx)\n        return track_output_data, tracks, track_id_count        # dict-20个track目标，dict-20个track目标，22\n\'> </span>', 'children': [{'type': 'heading', 'depth': 6, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/models/tracking_modules/track_manager.py</p><span class=\'hidden-code\' data-code=\'class TrackManager():\n    def predict_tracks(self, frm_id, tracks):\n        tk_boxes = np.zeros((len(tracks), 9), dtype=np.float32)\n        tk_name = list()\n        tk_score = list()\n        for i, tk in enumerate(tracks):\n            tk_boxes[i] = tk.`predict`(frm_id)[:9]              # 用卡尔曼滤波预测当前帧的3Dbox\n            tk_name.append(tk.name)\n            tk_score.append(tk.score)\n        tk_data = {&amp;#39;boxes_global&amp;#39;: np.array(tk_boxes),name&amp;#39;: np.array(tk_name),&amp;#39;score&amp;#39;: np.array(tk_score)&amp;#39;}\n        return tk_data\n\'> </span>', 'children': [{'type': 'heading', 'depth': 7, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/models/tracking_modules/kalman_filter/kalman_filter.py</p><span class=\'hidden-code\' data-code=\'class KalmanFilter(BaseKalmanFilter):\n    def predict(self, frame_id):\n        self.frame_id = frame_id\n        temp_x = copy.deepcopy(self.x)\n        if self.name == &amp;#39;Vehicle&amp;#39;:\n            speed_norm = np.linalg.norm(temp_x[self.z_dim:])\n            if speed_norm <= np.max(self.size)/2.:\n                temp_x[self.z_dim:] = 0.\n        self.x = self.F @ temp_x\n        self.P = self.F @ self.P @ self.F.T + self.Q\n        self.Q = self.Q * 1.5\n        self.miss += 1\n        self.hit = 0\n        bbox = np.concatenate((self.x.reshape(-1)[:3], self.size, self.heading.reshape(-1),self.x.reshape(-1)[3:5]), axis=0)\n        self.bbox = bbox\n        return self.bbox\n\'> </span>'}]}, {'type': 'heading', 'depth': 6, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/models/tracking_modules/data_association/data_association.py</p><span class=\'hidden-code\' data-code=\'class associate_det_to_tracks:\n    def __call__(self, det_data, track_data):\n        if self.stage == &amp;#39;one_stage&amp;#39;:\n            return self.one_stage(det_data, track_data, self.dist_thresholds)\n        elif self.stage == &amp;#39;two_stage&amp;#39;:\n            return self.`two_stage`(det_data, track_data)   \n\'> </span>', 'children': [{'type': 'heading', 'depth': 7, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/models/tracking_modules/data_association/data_association.py</p><span class=\'hidden-code\' data-code=\'class associate_det_to_tracks:\n    def two_stage(self, det_data, track_data):\n        det_box = det_data[&amp;#39;boxes_global&amp;#39;]          # (22, 7)\n        det_score = det_data[&amp;#39;score&amp;#39;]\n        num_pts_in_det = det_data[&amp;#39;num_points&amp;#39;]\n        det_name = det_data[&amp;#39;name&amp;#39;]\n        track_box = track_data[&amp;#39;boxes_global&amp;#39;]\n        track_name = track_data[&amp;#39;name&amp;#39;]\n        score_thresholds = np.array([self.score_thresholds[x] for x in det_name])\n        point_thresholds = np.array([self.point_thresholds[x] for x in det_name])               # {&amp;#39;Vehicle&amp;#39;: 0, &amp;#39;Pedestrian&amp;#39;: 0, &amp;#39;Cyclist&amp;#39;: 0}\n        if track_box.shape[0] == 0:              # 当最开始帧没有跟踪的时候\n            det_unmatch = np.flatnonzero(np.greater_equal(num_pts_in_det, point_thresholds))    # num_pts_in_det的shape(222,)的值都为0，  (22,)值从0-21\n            return np.zeros((0, 2), dtype=np.int), np.arange(0), det_unmatch, np.zeros_like(det_unmatch)\n        first_mask = np.greater_equal(det_score, score_thresholds) &amp; np.greater_equal(num_pts_in_det, point_thresholds)\n        first_det_index = np.flatnonzero(first_mask)\n        first_det_data = {&amp;#39;boxes_global&amp;#39;: det_box[first_det_index],&amp;#39;name&amp;#39;: det_name[first_det_index]}\n        first_matched, tarck_unmatch, det_unmatch, _ = self.`one_stage`(first_det_data, track_data, self.dist_thresholds)\n        first_matched[:, 1] = first_det_index[first_matched[:, 1]]\n        frist_det_unmatch_index = first_det_index[det_unmatch]\n        second_det_mask = ~first_mask\n        second_det_idx = np.flatnonzero(second_det_mask)\n        second_trk_mask = np.zeros(track_box.shape[0], dtype=np.bool)\n        second_trk_mask[tarck_unmatch] = True\n        second_trk_idx = np.flatnonzero(second_trk_mask)\n        second_det_data = {&amp;#39;boxes_global&amp;#39;: det_box[second_det_idx],&amp;#39;name&amp;#39;: det_name[second_det_idx]}\n        second_track_data = {&amp;#39;boxes_global&amp;#39;: track_box[second_trk_idx],&amp;#39;name&amp;#39;: track_name[second_trk_idx]}\n        second_matched, tarck_unmatch, det_unmatch, _ = self.`one_stage`(second_det_data, second_track_data, self.stage_distance_method)\n        second_matched[:, 0] = second_trk_idx[second_matched[:, 0]]\n        second_matched[:, 1] = second_det_idx[second_matched[:, 1]]\n        matched = np.concatenate((first_matched, second_matched), axis=0)\n        matched_stage = np.zeros(matched.shape[0], dtype=np.int)\n        matched_stage[:first_matched.shape[0]] = 0\n        matched_stage[first_matched.shape[0]:] = 1\n        tarck_unmatch = second_trk_idx[tarck_unmatch]\n        # det_unmatch = np.append(frist_det_unmatch_index, second_det_idx[det_unmatch])\n        det_unmatch = frist_det_unmatch_index\n        det_unmatch = det_unmatch[np.greater_equal(num_pts_in_det[det_unmatch], point_thresholds[det_unmatch])]\n        return matched, tarck_unmatch, det_unmatch, matched_stage\n\'> </span>'}]}, {'type': 'heading', 'depth': 6, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/models/tracking_modules/kalman_filter/kalman_filter.py</p><span class=\'hidden-code\' data-code=\'class KalmanFilter(BaseKalmanFilter):\n    def __init__(self, bbox, name, score, frame_id, track_id, num_points=0, x_dim=5, z_dim=3, delta_t=0.1, p=[1, 1], q=[1, 1], r=1, **kwargs):\n        super().__init__(bbox, name, score, frame_id, track_id, num_points=num_points, x_dim=x_dim, z_dim=z_dim, delta_t=delta_t, p=p, q=q, r=r)\nclass BaseKalmanFilter:    # Base Kalman Filter\n    def __init__(self, bbox, name, score, frame_id, track_id, num_points=0,x_dim=5, z_dim=3, delta_t=0.1, p=[1, 1], q=[1, 1], r=1):\n        self.x_dim = x_dim                   # 5        [x, y, z, vx, vy]\n        self.z_dim = z_dim                   # 3\n        self.size = bbox[3:6]\n        self.heading = bbox[6]\n        self.name = name                     # &amp;#39;Vehicle&amp;#39;\n        self.score = score\n        self.update_score = score\n        self.num_points = num_points\n        self.frame_id = frame_id\n        self.delta_t = delta_t               # 0.1\n        self.track_id = track_id             # 1\n        # init filter parameters   state: [x, y, z, vx, vy]\n        self.x = np.zeros((x_dim, 1), dtype=np.float32)\n        self.x[:z_dim, :] = copy.deepcopy(bbox[:3].reshape(3, 1))      # 前3维为x,y,z\n        self.bbox = np.zeros((bbox.shape[0]+2), dtype=np.float32)      # (9,)\n        self.bbox[:bbox.shape[0]] = copy.deepcopy(bbox)\n        self.F = np.eye(x_dim, dtype=np.float32)                       # (5, 5)\n        self.P = np.eye(x_dim, dtype=np.float32)\n        self.Q = np.eye(x_dim, dtype=np.float32)\n        self.H = np.eye(z_dim, x_dim, dtype=np.float32)                # (3, 5)\n        self.R = np.eye(z_dim, dtype=np.float32)\n        # array([[1. , 0. , 0. , 0.1, 0. ], [0. , 1. , 0. , 0. , 0.1], [0. , 0. , 1. , 0. , 0. ], [0. , 0. , 0. , 1. , 0. ], [0. , 0. , 0. , 0. , 1. ]], dtype=float32)\n        self.F[:2, 3:5] = np.eye(self.x_dim-self.z_dim, dtype=np.float32) * self.delta_t\n        self.P[:self.z_dim, :self.z_dim] = self.P[:self.z_dim, :self.z_dim]*p[0]\n        self.P[self.z_dim:, self.z_dim:] = self.P[self.z_dim:, self.z_dim:]*p[1]\n        # meas: [x, y, z]\n        self.Q[:3, :3] = self.Q[:3, :3]*q[0]\n        self.Q[3:, 3:] = self.Q[3:, 3:]*q[1]\n        self.R[:3, :3] = self.R[:3, :3]*r\n        # update count\n        self.hit = 1\n        self.miss = 0\n\'> </span>'}, {'type': 'heading', 'depth': 6, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">tracking/detzero_track/models/tracking_modules/track_manager.py</p><span class=\'hidden-code\' data-code=\'class TrackManager():                                            # 对于当前帧的跟踪器，之间的3Dbox做iou大的请阅读哎\n    def overlap_track_merge(self, tracks):\n        tk_boxes = np.zeros((len(tracks), 7), dtype=np.float32)\n        tk_age = np.zeros(len(tracks), dtype=np.int)\n        tk_area = np.zeros(len(tracks), dtype=np.float32)\n        tk_name = list()\n        for i, track in enumerate(tracks):\n            tk_boxes[i] = track.bbox[:7]\n            tk_age[i] = track.track_id\n            tk_area[i] = tk_boxes[i][3] * tk_boxes[i][4]\n            tk_name.append(track.name)\n        tk_name = np.array(tk_name)\n        tk_boxes_cuda = torch.from_numpy(tk_boxes).float().cuda()                                # torch.Size([22, 7])\n        bev_overlap_areas = data_association.bev_overlap_gpu(tk_boxes_cuda, tk_boxes_cuda)       # (22, 22)\n        tk_num, _ = bev_overlap_areas.shape\n        if tk_num > 0:                                                                           # 不同类别之间的iou都为0\n            for i, name in enumerate(tk_name): \n                diff_mask = (tk_name != name)\n                bev_overlap_areas[i, diff_mask] = 0.\n        keep_index_set = set()\n        deprecate_index_set = set()\n        for i in range(len(tk_boxes)):\n            if i in deprecate_index_set or i in keep_index_set: \n                continue\n            areas = bev_overlap_areas[i]\n            name = tk_name[i]\n            overlap_thresh = self.modules_dicts[&amp;#39;track_merge_config&amp;#39;][&amp;#39;class_threshold&amp;#39;][name]  # {&amp;#39;Vehicle&amp;#39;: 0.5, &amp;#39;Pedestrian&amp;#39;: 0.4, &amp;#39;Cyclist&amp;#39;: 0.4}\n            overlap_ratio = areas / (tk_area[i]+1e-9)\n            overlap_mask = overlap_ratio >= overlap_thresh\n            overlap_index = np.flatnonzero(overlap_mask)\n            overlap_ages = tk_age[overlap_index]\n            sort_idx = np.argsort(overlap_ages)\n            best_idx = overlap_index[sort_idx[0]]\n            if best_idx not in deprecate_index_set:\n                keep_index_set.add(best_idx)                                               # 保留跟踪最久的\n                bev_overlap_areas[:, overlap_index] = 0.\n                deprecate_index_set.update(overlap_index[sort_idx[1:]])\n        keep_index_list = sorted(list(keep_index_set))\n        deprecate_index_list = sorted(list(deprecate_index_set))\n        for idx in reversed(deprecate_index_list):\n            tracks.pop(idx)\n        return tracks\n\'> </span>'}]}]}]}]}]}]})</script><script src='https://study1994.github.io/study_html/npm/myjs/tooltip.js'></script>
</body>
</html>
