<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>DOTA_旋转数据处理</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
.hidden-code {
  display: none !important;
}
</style>
<link rel="stylesheet" href="https://study1994.github.io/study_html/npm/mycss/style.css">
</head>
<body>
    <svg id="mindmap"></svg>
    <script src="https://study1994.github.io/study_html/npm/myjs/d3@6.7.0.js"></script>
    <script src="https://study1994.github.io/study_html/npm/myjs/markmap-view@0.13.5.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
    <script>
        (r => {
            setTimeout(r);
        })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{'type': 'root', 'depth': 0, 'content': '', 'children': [{'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="https://github.com/hukaixuan19970627/DOTA_devkit_YOLO/blob/master/YOLO_Transform.py">代码来源DOTA_devkit_YOLO</a></p>'}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">YOLO_Transform.py</p><span class=\'hidden-code\' data-code=\'def dota2LongSideFormat(imgpath, txtpath, dstpath, extractclassname):         trans dota format to  (cls, c_x, c_y, Longest side, short side, angle:[0,179))\n    trans dota farmat to longside format\n    :param imgpath: the path of images\n    :param txtpath: the path of txt in dota format\n    :param dstpath: the path of txt in YOLO format\n    :param extractclassname: the category you selected\n    if os.path.exists(dstpath):\n        shutil.rmtree(dstpath)                       delete output folder\n    os.makedirs(dstpath)                             make new output folder\n    filelist = util.GetFileFromThisRootDir(txtpath)  fileist=[&amp;#39;/.../P0005.txt&amp;#39;, ..., /.../P000?.txt]\n    for fullname in filelist:                        fullname=&amp;#39;/.../P000?.txt&amp;#39;\n        objects = util.parse_dota_poly(fullname)     四个点\n        objects = [{&amp;#39;name&amp;#39;: &amp;#39;ship&amp;#39;, &amp;#39;difficult&amp;#39;: &amp;#39;1&amp;#39;, &amp;#39;poly&amp;#39;: [(1054.0, 1028.0), (1063.0, 1011.0), (1111.0, 1040.0), (1112.0, 1062.0)], &amp;#39;area&amp;#39;: 1159.5},...]\n        name = os.path.splitext(os.path.basename(fullname))[0]    name=&amp;#39;P000?&amp;#39;\n        img_fullname = os.path.join(imgpath, name + &amp;#39;.png&amp;#39;)       img_fullname=&amp;#39;/.../P000?.png&amp;#39;\n        img = Image.open(img_fullname)\n        img_w, img_h = img.size\n        with open(os.path.join(dstpath, name + &amp;#39;.txt&amp;#39;), &amp;#39;w&amp;#39;) as f_out:\n            num_gt = 0\n            for i, obj in enumerate(objects):\n                num_gt = num_gt + 1                   为当前有效gt计数\n                poly = obj[&amp;#39;poly&amp;#39;]                    poly=[(x1,y1),(x2,y2),(x3,y3),(x4,y4)]\n                poly = np.float32(np.array(poly))\n                poly[:, 0] = poly[:, 0]/img_w         四点坐标归一化\n                poly[:, 1] = poly[:, 1]/img_h\n                rect = cv2.minAreaRect(poly)          得到最小外接矩形的（中心(x,y), (宽,高), 旋转角度）\n                box = np.float32(cv2.boxPoints(rect))   返回rect四个点的值\n                c_x = rect[0][0]\n                c_y = rect[0][1]\n                w = rect[1][0]\n                h = rect[1][1]\n                theta = rect[-1]                      Range for angle is [-90，0)\n                trans_data = `cvminAreaRect2longsideformat`(c_x, c_y, w, h, theta)\n                if not trans_data:\n                    if theta != 90:                   Θ=90说明wh中有为0的元素，即gt信息不完整，无需提示异常，直接删除\n                        print(&amp;#39;opencv表示法转长边表示法出现异常,已将第%d个box排除,问题出现在该图片中:%s&amp;#39; % (i, img_fullname))\n                    num_gt = num_gt - 1\n                    continue\n                else:                                 range:[-180，0)\n                    c_x, c_y, longside, shortside, theta_longside = trans_data\n                bbox = np.array((c_x, c_y, longside, shortside))\n                if (sum(bbox `<`= 0) + sum(bbox[:2] `>`= 1) ) `>`= 1:    0`<`xy`<`1, 0`<`side`<`=1\n                    print(&amp;#39;bbox[:2]中有`>`= 1的元素,bbox中有`<`= 0的元素,已将第%d个box排除,问题出现在该图片中:%s&amp;#39; % (i, img_fullname))\n                    print(&amp;#39;出问题的longside形式数据:[%.16f, %.16f, %.16f, %.16f, %.1f]&amp;#39; % (c_x, c_y, longside, shortside, theta_longside))\n                    num_gt = num_gt - 1\n                    continue\n                if (obj[&amp;#39;name&amp;#39;] in extractclassname):\n                    id = extractclassname.index(obj[&amp;#39;name&amp;#39;])       id=类名的索引 比如&amp;#39;plane&amp;#39;对应id=0\n                else:\n                    print(&amp;#39;预定类别中没有类别:%s;已将该box排除,问题出现在该图片中:%s&amp;#39; % (obj[&amp;#39;name&amp;#39;], fullname))\n                    num_gt = num_gt - 1\n                    continue\n                theta_label = int(theta_longside + 180.5)          range int[0,180] 四舍五入\n                if theta_label == 180:                             range int[0,179]\n                    theta_label = 179\n                if id `>` 15 or id `<` 0:                              outline=&amp;#39;id x y longside shortside Θ&amp;#39; final check\n                    print(&amp;#39;id problems,问题出现在该图片中:%s&amp;#39; % (i, img_fullname))\n                    print(&amp;#39;出问题的longside形式数据:[%.16f, %.16f, %.16f, %.16f, %.1f]&amp;#39; % (\n                    c_x, c_y, longside, shortside, theta_longside))\n                if theta_label `<` 0 or theta_label `>` 179:\n                    print(&amp;#39;id problems,问题出现在该图片中:%s&amp;#39; % (i, img_fullname))\n                    print(&amp;#39;出问题的longside形式数据:[%.16f, %.16f, %.16f, %.16f, %.1f]&amp;#39; % (\n                        c_x, c_y, longside, shortside, theta_longside))\n                outline = str(id) + &amp;#39; &amp;#39; + &amp;#39; &amp;#39;.join(list(map(str, bbox))) + &amp;#39; &amp;#39; + str(theta_label)\n                f_out.write(outline + &amp;#39;\\n&amp;#39;)                         写入txt文件中并加上换行符号 \\n\n        if num_gt == 0:\n            os.remove(os.path.join(dstpath, name + &amp;#39;.txt&amp;#39;))  #\n            os.remove(img_fullname)\n            os.remove(fullname)\n            print(&amp;#39;%s 图片对应的txt不存在有效目标,已删除对应图片与txt&amp;#39; % img_fullname)\n    print(&amp;#39;已完成文件夹内DOTA数据形式到长边表示法的转换&amp;#39;)\n\'> </span>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">YOLO_Transform.py</p><span class=\'hidden-code\' data-code=\'def cvminAreaRect2longsideformat(x_c, y_c, width, height, theta):\n    # trans minAreaRect(x_c, y_c, width, height, θ) to longside format(x_c, y_c, longside, shortside, θ)\n    # 两者区别为:\n    #         当opencv表示法中width为最长边时（包括正方形的情况），则两种表示方法一致\n    #         当opencv表示法中width不为最长边 ，则最长边表示法的角度要在opencv的Θ基础上-90度         \n    # @param x_c: center_x\n    # @param y_c: center_y\n    # @param width: x轴逆时针旋转碰到的第一条边\n    # @param height: 与width不同的边\n    # @param theta: x轴逆时针旋转与width的夹角，由于原点位于图像的左上角，逆时针旋转角度为负 [-90, 0)\n    # @return: \n    #         x_c: center_x\n    #         y_c: center_y\n    #         longside: 最长边\n    #         shortside: 最短边\n    #         theta_longside: 最长边和x轴逆时针旋转的夹角，逆时针方向角度为负 [-180, 0)\n    # 意外情况:(此时要将它们恢复符合规则的opencv形式：wh交换，Θ置为-90)\n    # 竖直box：box_width < box_height  θ=0\n    # 水平box：box_width > box_height  θ=0\n    if theta == 0:\n        theta = -90\n        buffer_width = width\n        width = height\n        height = buffer_width\n    if theta > 0:\n        if theta != 90:              # Θ=90说明wh中有为0的元素，即gt信息不完整，无需提示异常，直接删除\n            print(&amp;#39;θ计算出现异常，当前数据为：%.16f, %.16f, %.16f, %.16f, %.1f;超出opencv表示法的范围：[-90,0)&amp;#39; % (x_c, y_c, width, height, theta))\n        return False\n    if theta < -90:\n        print(&amp;#39;θ计算出现异常，当前数据为：%.16f, %.16f, %.16f, %.16f, %.1f;超出opencv表示法的范围：[-90,0)&amp;#39; % (x_c, y_c, width, height, theta))\n        return False\n    if width != max(width, height):  # 若width不是最长边\n        longside = height\n        shortside = width\n        theta_longside = theta - 90\n    else:                            # 若width是最长边(包括正方形的情况)\n        longside = width\n        shortside = height\n        theta_longside = theta\n    if longside < shortside:\n        print(&amp;#39;旋转框转换表示形式后出现问题：最长边小于短边;[%.16f, %.16f, %.16f, %.16f, %.1f]&amp;#39; % (x_c, y_c, longside, shortside, theta_longside))\n        return False\n    if (theta_longside `<` -180 or theta_longside `>`= 0):\n        print(&amp;#39;旋转框转换表示形式时出现问题:θ超出长边表示法的范围：[-180,0);[%.16f, %.16f, %.16f, %.16f, %.1f]&amp;#39; % (x_c, y_c, longside, shortside, theta_longside))\n        return False\n    return x_c, y_c, longside, shortside, theta_longside\n\'> </span>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">YOLO_Transform.py</p><span class=\'hidden-code\' data-code=\'def drawLongsideFormatimg(imgpath, txtpath, dstpath, extractclassname, thickness=2):\n    根据labels绘制边框(label_format:classid, x_c_normalized, y_c_normalized, longside_normalized, shortside_normalized, Θ)\n    :param imgpath: the path of images\n    :param txtpath: the path of txt in longside format\n    :param dstpath: the path of image_drawed\n    :param extractclassname: the category you selected\n    if os.path.exists(dstpath):\n        shutil.rmtree(dstpath)                        delete output folder\n    os.makedirs(dstpath)                              make new output folder\n    设置画框的颜色    colors = [[178, 63, 143], [25, 184, 176], [238, 152, 129],....,[235, 137, 120]]随机设置RGB颜色\n    colors = [[random.randint(0, 255) for _ in range(3)] for _ in range(len(extractclassname))]\n    filelist = util.GetFileFromThisRootDir(txtpath)   fileist=[&amp;#39;/.../P0005.txt&amp;#39;, ..., /.../P000?.txt]\n    for fullname in filelist:                         fullname=&amp;#39;/.../P000?.txt&amp;#39;\n        objects = util.parse_longsideformat(fullname) objects[i] = [classid, x_c_normalized, y_c_normalized, longside_normalized, shortside_normalized, theta]\n        name = os.path.splitext(os.path.basename(fullname))[0]  name=&amp;#39;P000?&amp;#39;\n        img_fullname = os.path.join(imgpath, name + &amp;#39;.png&amp;#39;)     img_fullname=&amp;#39;/.../P000?.png&amp;#39;\n        img_savename = os.path.join(dstpath, name + &amp;#39;_.png&amp;#39;)    img_fullname=&amp;#39;/.../_P000?.png&amp;#39;\n        img = Image.open(img_fullname)                图像被打开但未被读取\n        img_w, img_h = img.size\n        img = cv2.imread(img_fullname)                读取图像像素\n        for i, obj in enumerate(objects):             obj = [classid, x_c_normalized, y_c_normalized, longside_normalized, shortside_normalized, float:0-179]\n            class_index = obj[0]\n            rect = `longsideformat2cvminAreaRect`(obj[1], obj[2], obj[3], obj[4], (obj[5]-179.9))    rect=[(x_c,y_c),(w,h),Θ] Θ:flaot[0-179]  -> (-180,0)\n            poly = np.float32(cv2.boxPoints(rect))    poly = [(x1,y1),(x2,y2),(x3,y3),(x4,y4)]返回rect对应的四个点的值 normalized\n            poly[:, 0] = poly[:, 0] * img_w           四点坐标反归一化 取整\n            poly[:, 1] = poly[:, 1] * img_h\n            poly = np.int0(poly)\n            cv2.drawContours(image=img,contours=[poly],contourIdx=-1,color=colors[int(class_index)],thickness=thickness)   画出来\n        cv2.imwrite(img_savename, img)\n\'> </span>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">YOLO_Transform.py</p><span class=\'hidden-code\' data-code=\'def longsideformat2cvminAreaRect(x_c, y_c, longside, shortside, theta_longside):\n    # trans longside format(x_c, y_c, longside, shortside, θ) to minAreaRect(x_c, y_c, width, height, θ)\n    # 两者区别为:\n    #         当opencv表示法中width为最长边时（包括正方形的情况），则两种表示方法一致\n    #         当opencv表示法中width不为最长边 ，则最长边表示法的角度要在opencv的Θ基础上-90度         \n    # @param x_c: center_x\n    # @param y_c: center_y\n    # @param longside: 最长边\n    # @param shortside: 最短边\n    # @param theta_longside: 最长边和x轴逆时针旋转的夹角，逆时针方向角度为负 [-180, 0)\n    # @return: ((x_c, y_c),(width, height),Θ)\n    #         x_c: center_x\n    #         y_c: center_y\n    #         width: x轴逆时针旋转碰到的第一条边最长边\n    #         height: 与width不同的边\n    #         theta: x轴逆时针旋转与width的夹角，由于原点位于图像的左上角，逆时针旋转角度为负 [-90, 0)\n    if (theta_longside `>`= -180 and theta_longside `<` -90):  # width is not the longest side\n        width = shortside\n        height = longside\n        theta = theta_longside + 90\n    else:\n        width = longside\n        height =shortside\n        theta = theta_longside\n    if theta `<` -90 or theta `>`= 0:\n        print(&amp;#39;当前θ=%.1f，超出opencv的θ定义范围[-90, 0)&amp;#39; % theta)\n    return ((x_c, y_c), (width, height), theta)\n\'> </span>'}]}]})</script><script src='https://study1994.github.io/study_html/npm/myjs/tooltip.js'></script>
</body>
</html>
