<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>DOTA_旋转数据处理</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://study1994.github.io/study_html/npm/prism.css"><link rel="stylesheet" href="https://study1994.github.io/study_html/npm/markmap-toolbar@0.13.5/dist/style.css">
</head>
<body>
    <svg id="mindmap"></svg>
    <script src="https://study1994.github.io/study_html/npm/d3@6.7.0"></script>
    <script src="https://study1994.github.io/study_html/npm/markmap-view@0.13.5"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
    <script>
        (r => {
            setTimeout(r);
        })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{'type': 'root', 'depth': 0, 'content': '', 'children': [{'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p><a href="https://github.com/hukaixuan19970627/DOTA_devkit_YOLO/blob/master/YOLO_Transform.py">代码来源DOTA_devkit_YOLO</a></p>'}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">YOLO_Transform.py</p><font size="0"><pre class="language-python" style="line-height: 0.01; "><code class="language-python">def dota2LongSideFormat(imgpath, txtpath, dstpath, extractclassname):         <span style=\'color: red\'>trans dota format to  (cls, c_x, c_y, Longest side, short side, angle:[0,179))</span>\n    <span style=\'color: red\'>trans dota farmat to longside format</span>\n    <span style=\'color: red\'>:param imgpath: the path of images</span>\n    <span style=\'color: red\'>:param txtpath: the path of txt in dota format</span>\n    <span style=\'color: red\'>:param dstpath: the path of txt in YOLO format</span>\n    <span style=\'color: red\'>:param extractclassname: the category you selected</span>\n    if os.path.exists(dstpath):\n        shutil.rmtree(dstpath)                       <span style=\'color: red\'>delete output folder</span>\n    os.makedirs(dstpath)                             <span style=\'color: red\'>make new output folder</span>\n    filelist = util.GetFileFromThisRootDir(txtpath)  <span style=\'color: red\'>fileist=[\'/.../P0005.txt\', ..., /.../P000?.txt]</span>\n    for fullname in filelist:                        <span style=\'color: red\'>fullname=\'/.../P000?.txt\'</span>\n        objects = util.parse_dota_poly(fullname)     <span style=\'color: red\'>四个点</span>\n        <span style=\'color: red\'>objects = [{\'name\': \'ship\', \'difficult\': \'1\', \'poly\': [(1054.0, 1028.0), (1063.0, 1011.0), (1111.0, 1040.0), (1112.0, 1062.0)], \'area\': 1159.5},...]</span>\n        name = os.path.splitext(os.path.basename(fullname))[0]    <span style=\'color: red\'>name=\'P000?\'</span>\n        img_fullname = os.path.join(imgpath, name + \'.png\')       <span style=\'color: red\'>img_fullname=\'/.../P000?.png\'</span>\n        img = Image.open(img_fullname)\n        img_w, img_h = img.size\n        with open(os.path.join(dstpath, name + \'.txt\'), \'w\') as f_out:\n            num_gt = 0\n            for i, obj in enumerate(objects):\n                num_gt = num_gt + 1                   <span style=\'color: red\'>为当前有效gt计数</span>\n                poly = obj[\'poly\']                    <span style=\'color: red\'>poly=[(x1,y1),(x2,y2),(x3,y3),(x4,y4)]</span>\n                poly = np.float32(np.array(poly))\n                poly[:, 0] = poly[:, 0]/img_w         <span style=\'color: red\'>四点坐标归一化</span>\n                poly[:, 1] = poly[:, 1]/img_h\n                rect = cv2.minAreaRect(poly)          <span style=\'color: red\'>得到最小外接矩形的（中心(x,y), (宽,高), 旋转角度）</span>\n                <span style=\'color: red\'>box = np.float32(cv2.boxPoints(rect))  </span>\n                c_x = rect[0][0]\n                c_y = rect[0][1]\n                w = rect[1][0]\n                h = rect[1][1]\n                theta = rect[-1]                      <span style=\'color: red\'>Range for angle is [-90，0)</span>\n                trans_data = <span style=\'color: green;font-weight: bold;\'>cvminAreaRect2longsideformat</span>(c_x, c_y, w, h, theta)\n                if not trans_data:\n                    if theta != 90:                   <span style=\'color: red\'>Θ=90说明wh中有为0的元素，即gt信息不完整，无需提示异常，直接删除</span>\n                        print(\'opencv表示法转长边表示法出现异常,已将第%d个box排除,问题出现在该图片中:%s\' % (i, img_fullname))\n                    num_gt = num_gt - 1\n                    continue\n                else:                                 <span style=\'color: red\'>range:[-180，0)</span>\n                    c_x, c_y, longside, shortside, theta_longside = trans_data\n                bbox = np.array((c_x, c_y, longside, shortside))\n                if (sum(bbox <span style=\'color: green;font-weight: bold;\'><</span>= 0) + sum(bbox[:2] <span style=\'color: green;font-weight: bold;\'>></span>= 1) ) <span style=\'color: green;font-weight: bold;\'>></span>= 1:    <span style=\'color: red\'>0<span style=\'color: green;font-weight: bold;\'><</span>xy<span style=\'color: green;font-weight: bold;\'><</span>1, 0<span style=\'color: green;font-weight: bold;\'><</span>side<span style=\'color: green;font-weight: bold;\'><</span>=1</span>\n                    print(\'bbox[:2]中有<span style=\'color: green;font-weight: bold;\'>></span>= 1的元素,bbox中有<span style=\'color: green;font-weight: bold;\'><</span>= 0的元素,已将第%d个box排除,问题出现在该图片中:%s\' % (i, img_fullname))\n                    print(\'出问题的longside形式数据:[%.16f, %.16f, %.16f, %.16f, %.1f]\' % (c_x, c_y, longside, shortside, theta_longside))\n                    num_gt = num_gt - 1\n                    continue\n                if (obj[\'name\'] in extractclassname):\n                    id = extractclassname.index(obj[\'name\'])       <span style=\'color: red\'>id=类名的索引 比如\'plane\'对应id=0</span>\n                else:\n                    print(\'预定类别中没有类别:%s;已将该box排除,问题出现在该图片中:%s\' % (obj[\'name\'], fullname))\n                    num_gt = num_gt - 1\n                    continue\n                theta_label = int(theta_longside + 180.5)          <span style=\'color: red\'>range int[0,180] 四舍五入</span>\n                if theta_label == 180:                             <span style=\'color: red\'>range int[0,179]</span>\n                    theta_label = 179\n                if id <span style=\'color: green;font-weight: bold;\'>></span> 15 or id <span style=\'color: green;font-weight: bold;\'><</span> 0:                              <span style=\'color: red\'>outline=\'id x y longside shortside Θ\' final check</span>\n                    print(\'id problems,问题出现在该图片中:%s\' % (i, img_fullname))\n                    print(\'出问题的longside形式数据:[%.16f, %.16f, %.16f, %.16f, %.1f]\' % (\n                    c_x, c_y, longside, shortside, theta_longside))\n                if theta_label <span style=\'color: green;font-weight: bold;\'><</span> 0 or theta_label <span style=\'color: green;font-weight: bold;\'>></span> 179:\n                    print(\'id problems,问题出现在该图片中:%s\' % (i, img_fullname))\n                    print(\'出问题的longside形式数据:[%.16f, %.16f, %.16f, %.16f, %.1f]\' % (\n                        c_x, c_y, longside, shortside, theta_longside))\n                outline = str(id) + \' \' + \' \'.join(list(map(str, bbox))) + \' \' + str(theta_label)\n                f_out.write(outline + \'\\n\')                         <span style=\'color: red\'>写入txt文件中并加上换行符号 \\n</span>\n        if num_gt == 0:\n            os.remove(os.path.join(dstpath, name + \'.txt\'))  #\n            os.remove(img_fullname)\n            os.remove(fullname)\n            print(\'%s 图片对应的txt不存在有效目标,已删除对应图片与txt\' % img_fullname)\n    print(\'已完成文件夹内DOTA数据形式到长边表示法的转换\')\n</code></pre></font>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">YOLO_Transform.py</p><font size="0"><pre class="language-python" style="line-height: 0.01; "><code class="language-python">def cvminAreaRect2longsideformat(x_c, y_c, width, height, theta):\n    <span style=\'color: red\'># trans minAreaRect(x_c, y_c, width, height, θ) to longside format(x_c, y_c, longside, shortside, θ)</span>\n    <span style=\'color: red\'># 两者区别为:</span>\n    <span style=\'color: red\'>#         当opencv表示法中width为最长边时（包括正方形的情况），则两种表示方法一致</span>\n    <span style=\'color: red\'>#         当opencv表示法中width不为最长边 ，则最长边表示法的角度要在opencv的Θ基础上-90度         </span>\n    <span style=\'color: red\'># @param x_c: center_x</span>\n    <span style=\'color: red\'># @param y_c: center_y</span>\n    <span style=\'color: red\'># @param width: x轴逆时针旋转碰到的第一条边</span>\n    <span style=\'color: red\'># @param height: 与width不同的边</span>\n    <span style=\'color: red\'># @param theta: x轴逆时针旋转与width的夹角，由于原点位于图像的左上角，逆时针旋转角度为负 [-90, 0)</span>\n    <span style=\'color: red\'># @return: </span>\n    <span style=\'color: red\'>#         x_c: center_x</span>\n    <span style=\'color: red\'>#         y_c: center_y</span>\n    <span style=\'color: red\'>#         longside: 最长边</span>\n    <span style=\'color: red\'>#         shortside: 最短边</span>\n    <span style=\'color: red\'>#         theta_longside: 最长边和x轴逆时针旋转的夹角，逆时针方向角度为负 [-180, 0)</span>\n    <span style=\'color: red\'># 意外情况:(此时要将它们恢复符合规则的opencv形式：wh交换，Θ置为-90)</span>\n    <span style=\'color: red\'># 竖直box：box_width < box_height  θ=0</span>\n    <span style=\'color: red\'># 水平box：box_width > box_height  θ=0</span>\n    if theta == 0:\n        theta = -90\n        buffer_width = width\n        width = height\n        height = buffer_width\n    if theta > 0:\n        if theta != 90:              <span style=\'color: red\'># Θ=90说明wh中有为0的元素，即gt信息不完整，无需提示异常，直接删除</span>\n            print(\'θ计算出现异常，当前数据为：%.16f, %.16f, %.16f, %.16f, %.1f;超出opencv表示法的范围：[-90,0)\' % (x_c, y_c, width, height, theta))\n        return False\n    if theta < -90:\n        print(\'θ计算出现异常，当前数据为：%.16f, %.16f, %.16f, %.16f, %.1f;超出opencv表示法的范围：[-90,0)\' % (x_c, y_c, width, height, theta))\n        return False\n    if width != max(width, height):  <span style=\'color: red\'># 若width不是最长边</span>\n        longside = height\n        shortside = width\n        theta_longside = theta - 90\n    else:                            <span style=\'color: red\'># 若width是最长边(包括正方形的情况)</span>\n        longside = width\n        shortside = height\n        theta_longside = theta\n    if longside < shortside:\n        print(\'旋转框转换表示形式后出现问题：最长边小于短边;[%.16f, %.16f, %.16f, %.16f, %.1f]\' % (x_c, y_c, longside, shortside, theta_longside))\n        return False\n    if (theta_longside <span style=\'color: green;font-weight: bold;\'><</span> -180 or theta_longside <span style=\'color: green;font-weight: bold;\'>></span>= 0):\n        print(\'旋转框转换表示形式时出现问题:θ超出长边表示法的范围：[-180,0);[%.16f, %.16f, %.16f, %.16f, %.1f]\' % (x_c, y_c, longside, shortside, theta_longside))\n        return False\n    return x_c, y_c, longside, shortside, theta_longside\n</code></pre></font>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">YOLO_Transform.py</p><font size="0"><pre class="language-python" style="line-height: 0.01; "><code class="language-python">def drawLongsideFormatimg(imgpath, txtpath, dstpath, extractclassname, thickness=2):\n    <span style=\'color: red\'>根据labels绘制边框(label_format:classid, x_c_normalized, y_c_normalized, longside_normalized, shortside_normalized, Θ)</span>\n    <span style=\'color: red\'>:param imgpath: the path of images</span>\n    <span style=\'color: red\'>:param txtpath: the path of txt in longside format</span>\n    <span style=\'color: red\'>:param dstpath: the path of image_drawed</span>\n    <span style=\'color: red\'>:param extractclassname: the category you selected</span>\n    if os.path.exists(dstpath):\n        shutil.rmtree(dstpath)                        <span style=\'color: red\'>delete output folder</span>\n    os.makedirs(dstpath)                              <span style=\'color: red\'>make new output folder</span>\n    <span style=\'color: red\'>设置画框的颜色    colors = [[178, 63, 143], [25, 184, 176], [238, 152, 129],....,[235, 137, 120]]随机设置RGB颜色</span>\n    colors = [[random.randint(0, 255) for _ in range(3)] for _ in range(len(extractclassname))]\n    filelist = util.GetFileFromThisRootDir(txtpath)   <span style=\'color: red\'>fileist=[\'/.../P0005.txt\', ..., /.../P000?.txt]</span>\n    for fullname in filelist:                         <span style=\'color: red\'>fullname=\'/.../P000?.txt\'</span>\n        objects = util.parse_longsideformat(fullname) <span style=\'color: red\'>objects[i] = [classid, x_c_normalized, y_c_normalized, longside_normalized, shortside_normalized, theta]</span>\n        name = os.path.splitext(os.path.basename(fullname))[0]  <span style=\'color: red\'>name=\'P000?\'</span>\n        img_fullname = os.path.join(imgpath, name + \'.png\')     <span style=\'color: red\'>img_fullname=\'/.../P000?.png\'</span>\n        img_savename = os.path.join(dstpath, name + \'_.png\')    <span style=\'color: red\'>img_fullname=\'/.../_P000?.png\'</span>\n        img = Image.open(img_fullname)                <span style=\'color: red\'>图像被打开但未被读取</span>\n        img_w, img_h = img.size\n        img = cv2.imread(img_fullname)                <span style=\'color: red\'>读取图像像素</span>\n        for i, obj in enumerate(objects):             <span style=\'color: red\'>obj = [classid, x_c_normalized, y_c_normalized, longside_normalized, shortside_normalized, float:0-179]</span>\n            class_index = obj[0]\n            rect = <span style=\'color: green;font-weight: bold;\'>longsideformat2cvminAreaRect</span>(obj[1], obj[2], obj[3], obj[4], (obj[5]-179.9))    <span style=\'color: red\'>rect=[(x_c,y_c),(w,h),Θ] Θ:flaot[0-179]  -> (-180,0)</span>\n            poly = np.float32(cv2.boxPoints(rect))    <span style=\'color: red\'>poly = [(x1,y1),(x2,y2),(x3,y3),(x4,y4)]返回rect对应的四个点的值 normalized</span>\n            poly[:, 0] = poly[:, 0] * img_w           <span style=\'color: red\'>四点坐标反归一化 取整</span>\n            poly[:, 1] = poly[:, 1] * img_h\n            poly = np.int0(poly)\n            cv2.drawContours(image=img,contours=[poly],contourIdx=-1,color=colors[int(class_index)],thickness=thickness)   <span style=\'color: red\'>画出来</span>\n        cv2.imwrite(img_savename, img)\n</code></pre></font>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">YOLO_Transform.py</p><font size="0"><pre class="language-python" style="line-height: 0.01; "><code class="language-python">def longsideformat2cvminAreaRect(x_c, y_c, longside, shortside, theta_longside):\n    <span style=\'color: red\'># trans longside format(x_c, y_c, longside, shortside, θ) to minAreaRect(x_c, y_c, width, height, θ)</span>\n    <span style=\'color: red\'># 两者区别为:</span>\n    <span style=\'color: red\'>#         当opencv表示法中width为最长边时（包括正方形的情况），则两种表示方法一致</span>\n    <span style=\'color: red\'>#         当opencv表示法中width不为最长边 ，则最长边表示法的角度要在opencv的Θ基础上-90度         </span>\n    <span style=\'color: red\'># @param x_c: center_x</span>\n    <span style=\'color: red\'># @param y_c: center_y</span>\n    <span style=\'color: red\'># @param longside: 最长边</span>\n    <span style=\'color: red\'># @param shortside: 最短边</span>\n    <span style=\'color: red\'># @param theta_longside: 最长边和x轴逆时针旋转的夹角，逆时针方向角度为负 [-180, 0)</span>\n    <span style=\'color: red\'># @return: ((x_c, y_c),(width, height),Θ)</span>\n    <span style=\'color: red\'>#         x_c: center_x</span>\n    <span style=\'color: red\'>#         y_c: center_y</span>\n    <span style=\'color: red\'>#         width: x轴逆时针旋转碰到的第一条边最长边</span>\n    <span style=\'color: red\'>#         height: 与width不同的边</span>\n    <span style=\'color: red\'>#         theta: x轴逆时针旋转与width的夹角，由于原点位于图像的左上角，逆时针旋转角度为负 [-90, 0)</span>\n    if (theta_longside <span style=\'color: green;font-weight: bold;\'>></span>= -180 and theta_longside <span style=\'color: green;font-weight: bold;\'><</span> -90):  <span style=\'color: red\'># width is not the longest side</span>\n        width = shortside\n        height = longside\n        theta = theta_longside + 90\n    else:\n        width = longside\n        height =shortside\n        theta = theta_longside\n    if theta <span style=\'color: green;font-weight: bold;\'><</span> -90 or theta <span style=\'color: green;font-weight: bold;\'>></span>= 0:\n        print(\'当前θ=%.1f，超出opencv的θ定义范围[-90, 0)\' % theta)\n    return ((x_c, y_c), (width, height), theta)\n</code></pre></font>'}]}]})</script></body>
</html>
