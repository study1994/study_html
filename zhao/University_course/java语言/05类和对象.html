<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>05类和对象</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://study1994.github.io/study_html/npm/prism.css"><link rel="stylesheet" href="https://study1994.github.io/study_html/npm/markmap-toolbar@0.13.5/dist/style.css">
</head>
<body>
    <svg id="mindmap"></svg>
    <script src="https://study1994.github.io/study_html/npm/d3@6.7.0"></script>
    <script src="https://study1994.github.io/study_html/npm/markmap-view@0.13.5"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
    <script>
        (r => {
            setTimeout(r);
        })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{'type': 'root', 'depth': 0, 'content': '', 'children': [{'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">导读</p>\n<p>面向对象技术有三个特征，分别是<code>数据封装（类）</code>、<code>继承</code>和<code>多态</code><br>\n讲解<code>面向对象的基本概念</code>，然后主要讲解<code>与类和对象有关的内容</code><br></p>'}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">01面向对象的基本概念</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">对象的概念</p>\n<p>客观世界中的任何事物都是对象，不管是有生命<code>人</code>的还是无生命的、具体的还是抽象<code>半径为2的圆</code>的都可以看作对象<br>\n每一个对象都有两个特征，一个是属性<code>半径</code>，一个是行为<code>求面积</code><br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">类的概念</p>类是对同一类对象的属性和行为的封装<br>\n抽象就是忽略事物中与当前目标无关的非本质特征，把具有共性和行为的事物划为一类，得到一个抽象的结果<br>\n抽象应该根据问题的需要而抽象，同一类对象在不同领域抽象的结果有所不同<br>\n抽象之后应该进行封装，把对象的属性和行为结合并尽可能隐蔽对象的内部细节<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">继承</p>继承是在已有类基础上生成新类的过程<br>\n派生类或子类，基类或父类<br>\n继承具有传递性。继承可分为多重继承与单重继承<br>\n<font size="0"><pre class="language-java"><code class="language-java">public class Penguin extends Animal { \n    public Penguin(String myName, int myid) { \n        super(myName, myid); \n    } \n}\n</code></pre></font>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">多态</p>同一类对象表现出的不同行为<br>\n用父类的对象表示子类对象，通过父类对象表示对象行为时，<br>\n运行时系统能够判定父类对象表示的是自身对象还是哪一个子类的对象，<br>\n从而能准确地使对象所在类中的行为表现出来，实现多态性<br>'}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">02类</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">类的定义</p>\n<p><code>class 类名{域的定义；方法的定义；}</code><br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">域定义</p>\n<p><code>域数据类型 域1[=初值1],域2[=初值2],……;</code>double radius;<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">方法</p>', 'children': [{'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">方法的定义</p>\n<p><code>方法类型 方法名([形式参数]){//……}</code>void move(int offX,int offY);<br>\nreturn 表达式;<br></p>'}, {'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">方法的使用</p>\n<p>方法的<code>调用</code>;定义方法-<code>形式参数</code>;调用方法-<code>实际参数</code><br></p>'}, {'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">方法的递归调用</p>直接或间接地调用了自身，这种调用称为递归调用<br>\n计算n!<br>'}, {'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">方法的重载</p>同一作用域，具有相同方法名、不同参数表的方法<br>\nint add(int a,int b){//……}<br>\ndouble add(double a,double b){//…….}<br>\nint add(int a,int b,int c){//……}<br>'}]}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">03对象</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">对象的概念</p>定义了一个类相当于定义了一个新的数据类型<br>\n由类所定义的变量就是对象，对象也算是变量<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">对象的创建与表示</p>声明对象名:类名 对象名;<br>\nCircle myCircle;<br>\n创建对象:new 构造方法([实际参数])<br>\nnew Circle()<br>\n表示对象:对象名=new 构造方法();<br>\nmyCricle=new Circle();Circle myCircle=new Circle();<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">对象的内存模型</p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">对象的使用</p>\n<p><code>对象名.域名</code>;<code>对象名.方法名([实际参数表列])</code><br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">this关键字</p>this是对象名，是对象的别名，又称对象的引用<br>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">04访问权限</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">访问权限的概念</p>访问限定词，分别是private(私有的)、protected(保护的)和public(公有的)<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">私有域和私有方法</p>private 数据类型 域;<br>\nprivate 方法类型 方法名（[参数]）{//方法体}<br>\n类体之外不能通过对象名直接访问<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">公有域和公有方法</p>public 数据类型 域;<br>\npublic 方法类型 方法名（[参数]）{//方法体}<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">保护的域和保护的方法</p>protected 数据类型 域;<br>\nprotected 方法类型 方法名（[参数]）{//方法体}<br>\n可以被子类中的其它方法直接访问；<br>\n在同一个包中，可以通过对象名直接访问；<br>\n不是同一包中的非子类，不能通过对象名直接访问。<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">默认访问权限的域和方法</p>默认的域或方法具有包的访问权限<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">访问权限的作用范围</p>同一个类:public,protected,默认的,private<br>\n同一个包:public,protected,默认的<br>\n不同包的子类:public,protected<br>\n不同包的非子类:public<br>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">05构造方法</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">构造方法的作用</p>用于创建对象<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">实例初始化器</p>是一个方法，但它只有方法体，没有方法头部<br>\n{实例初始化器方法体}<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">构造方法定义</p>方法名([形式参数表列]){},方法名”与所在类的类名<br>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">06参数的传递</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">基本类型数据作方法的参数</p>基本类型的参数<br>\n非基本类型的参数:数组和对象类型的参数<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">引用类型作方法的参数</p>数组类型的数据作方法的参数<br>\n对象作方法的参数<br>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">07对象组合</p>一个对象中的域是其它类的对象-组合类<br>\n在使用组合对象时，需要初始化组合类中的对象域<br>'}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">08package和import</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">都是与包和类操作有关的语句</p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">package语句</p>Java程序中可以定义若干个包，每个包中包含类，还可以再包含包（子包）<br>\n定义：package 包名[.子包名1[.子包名2[…]]];<br>\n使用：包名[.子包名1[.子包名2[…]]].类名 对象名;<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">import语句</p>\n<p><code>import [包名[.子包名1[.子包名2[….子包n]]].*;</code><br>\n<code>import [包名[.子包名1[.子包名2[….子包n]]].类名;</code><br></p>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">09对象数组</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">概念</p>一个数组中的元素是对象类型<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">定义与使用</p>类名 对象数组名[];<br>\n为对象数组分配内存空间:对象数组名=new 类名[数组长度];<br>\n<font size="0"><pre class="language-java"><code class="language-java">Student stu[]=new Student[30];\nfor(int i=0;i<stu.length;i++)\n    stu[i]=new Student();\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">定义与使用</p>采用初始化的方法创建:类名 对象数组名[]={对象表列};<br>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">10static与static修饰成员</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">static修饰域</p>类域，静态域：[访问限定词] static 数据类型 域名[=初值];<br>\n静态域可以通过对象名或方法访问：类名.静态域名<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">static 修饰方法</p>类方法或静态方法：static 方法类型 方法([形式参数表列]){//方法体}<br>\n类名调用静态方法：类名.方法名([实际参数表列])<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">静态初始化器</p>是一个方法，但是它无方法名：static{//静态域初始化语句}<br>\n当静态初始化器所在的类第1次被使用时，静态初始化器首先被调用<br>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">11其它类型的类</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">内部类</p>一个类定义在另外一个类的内部<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">匿名类</p>匿名类即无名类，使用时直接用匿名类生成一个对象<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">局部类</p>定义在方法体中，或者定义在语句中<br>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">12小结</p>面向对象技术有三个特征，分别是数据封装、继承和多态。<br>\n类是对一类具有相同属性和行为的对象的封装。<br>\n将简单对象进行组合形成较复杂的对象，所以可以定义组合类。<br>\n由类所定义的变量就称为对象。创建对象时必须调用构造方法。<br>\n如果需要一个类中的多个对象，则可以定义对象数组。<br>\n定义静态初始化器对静态域进行初始化。<br>\n定义方法时如果有参数，则调用方法时应该向方法传递数据，分为基本类型和非基本类型。<br>'}]})</script></body>
</html>
