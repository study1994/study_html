<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>08结构体及其他构造数据类型</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://study1994.github.io/study_html/npm/prism.css"><link rel="stylesheet" href="https://study1994.github.io/study_html/npm/markmap-toolbar@0.13.5/dist/style.css">
</head>
<body>
    <svg id="mindmap"></svg>
    <script src="https://study1994.github.io/study_html/npm/d3@6.7.0"></script>
    <script src="https://study1994.github.io/study_html/npm/markmap-view@0.13.5"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
    <script>
        (r => {
            setTimeout(r);
        })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{'type': 'root', 'depth': 0, 'content': '', 'children': [{'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">概述</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">结构体：结构体是数目固定、类型不同的若干有序变量的集合；</p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">共用体：共用体允许在同一内存中存放不同类型的变量；</p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">枚举类型：枚举类型是把变量的值一一列举出来，变量的值只限于列举出来的值；</p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">位域类型：位域是结构体的一种变形，用于方便地访问二进制位；</p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">用户自定义类型：typedef能为已存在的数据类型定义新的名字。</p>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">结构体</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">声明</p><font size="0"><pre class="language-c"><code class="language-c">struct 结构体名{\n\t数据类型 成员1的名字;\n\t数据类型 成员2的名字;\n\t…\n};             <span style=\'color: red\'>// 分号不能少，因为这是一条完整的语句</span>\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">先声明后定义</p><font size="0"><pre class="language-c"><code class="language-c">struct emp{\n\tint no;\t\t\t\t    /*工号为整型*/\n\tchar name[20];\t\t    /*姓名为字符串*/\n\tchar state;\t\t\t    /*婚姻状况为字符型*/\n};\nstruct emp emp1,emp2;\t\t/*定义结构体变量emp1和emp2*/\n<span style=\'color: red\'>// 用宏定义使用符号常量来表示结构体类型</span>\n#define EMP struct emp\nEMP emp1,emp2;\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">声明结构体类型的同时定义变量</p><font size="0"><pre class="language-c"><code class="language-c">struct emp{\n\tint no;\t\t\t\t    /*工号为整型*/\n\tchar name[20];\t\t    /*姓名为字符串*/\n\tchar state;\t\t\t    /*婚姻状况为字符型*/\n}emp1,emp2;\t\t            /*定义结构体变量emp1和emp2*/\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">直接定义结构体类型变量而不指定结构体名</p><font size="0"><pre class="language-c"><code class="language-c">struct{\n\tint no;\t\t\t\t    /*工号为整型*/\n\tchar name[20];\t\t    /*姓名为字符串*/\n\tchar state;\t\t\t    /*婚姻状况为字符型*/\n}emp1,emp2;\t\t            /*定义结构体变量emp1和emp2*/\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">引用</p>emp1.no=1001;<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">其它说明</p>类型与变量的区别：在编译时，对类型不分配内存空间，而变量却要分配内存空间；类型不能赋值、存取或运算，而变量可以。<br>\n不能将结构体作为一个整体进行输入输出，但可以将一个结构体变量赋值给类型相同的另一个结构体变量。<br>\n如果结构体是嵌套定义的，则在引用结构体成员时，要引用到最内层成员。<br>\n结构体成员可以像普通变量一样参与相应的运算。<br>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">变量初始化</p>struct 结构体名 结构体变量名={初始数据};<br>\n<font size="0"><pre class="language-c"><code class="language-c">struct stu\t\t\t\t\t\t            /*结构体*/\n{\n\tint num;\n\tchar *name;\n\tchar sex;\n\tfloat score;\n}boy2,boy1={102,"Zhangping",\'M\',78.5};\t\t/*初始化结构体变量*/\nboy2=boy1;\t\t\t\t                    /*相同类型的结构体变量相互赋值*/\n</code></pre></font>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">结构体数组</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">定义及初始化</p><font size="0"><pre class="language-c"><code class="language-c">struct stu\t\t\t\t\t\t/*先声明结构体类型再定义结构体数组*/\n{\n\tint num;\n\tchar name[20];\n\tfloat score;\n};\nstruct stu boy[50];\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">定义及初始化</p><font size="0"><pre class="language-c"><code class="language-c">struct stu\n{\n\tint num;\n\tchar name[20];\n\tchar sex;\n\tint age;\n\tfloat score;\n}boy[2]={\n    {101,"Li ping",\'M\',20,45},\n    {102,"Zhang ping",\'M\',21,62.5};\n};\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">引用</p>\n<p>结构体数组名[下标].成员名：<code>n=boy[1].age;</code><br></p>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">结构体指针</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">定义</p>`struct 结构名 *结构体变量名;`<br>\n<font size="0"><pre class="language-c"><code class="language-c">struct stu{\t\t\t\t\t/*声明结构体和结构体名字*/\n\tchar *name;\t\t\t    /*姓名*/\n\tint num;\t\t\t\t/*学号*/\n};\nstruct stu *pstu;\t\t\t/*定义结构体指针变量*/\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">初始化</p><font size="0"><pre class="language-c"><code class="language-c">struct stu boy={"Make", 12, 17, 106.5};\t\t/*定义结构体变量boy*/\npstu=&boy;\t\t\t\t\t                /*使pstu指向结构体变量boy*/\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">访问</p>成员运算符_圆点运算符:`(*结构指针变量).成员名`<br>\n指向运算符_箭头运算符:`指向结构体的指针变量名->成员名`<br>\n<font size="0"><pre class="language-c"><code class="language-c">boy.num=201801;\t\t\t/*使用成员运算符访问结构体成员*/\n(*pstu).num=201801;\t\t/*因为pstu指向结构体变量boy，因此，*pstu等于boy*/\npstu->num=201801;\t\t/*使用指向运算符访问结构体成员*\n</code></pre></font>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">链表</p>'}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">共用体</p>'}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">枚举类型</p>'}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">位域结构</p>'}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">用户自定义类型</p>'}]})</script></body>
</html>
