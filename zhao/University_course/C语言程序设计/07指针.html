<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>07指针</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://study1994.github.io/study_html/npm/prism.css"><link rel="stylesheet" href="https://study1994.github.io/study_html/npm/markmap-toolbar@0.13.5/dist/style.css">
</head>
<body>
    <svg id="mindmap"></svg>
    <script src="https://study1994.github.io/study_html/npm/d3@6.7.0"></script>
    <script src="https://study1994.github.io/study_html/npm/markmap-view@0.13.5"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
    <script>
        (r => {
            setTimeout(r);
        })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{'type': 'root', 'depth': 0, 'content': '', 'children': [{'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">指针和地址的概念</p>\n<p>数据存放在存储器,存储器的<code>一个字节</code>称为<code>一个内存单元</code>,为每个内存单元<code>编号</code>来正确地访问这些内存单元<br>\n通过编号访问内存单元的编号称为<code>内存单元的地址</code>,也称为<code>指针</code><br>\n<code>指针变量</code>的值就是某个内存单元的地址或称为某内存单元的指针<br></p>'}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">指针变量的定义和使用</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">定义</p>`类型说明符 *指针变量名1,*指针变量名2…;`<br>\n指针变量定义中的“数据类型”是指针指向的目标数据的类型<br>\n<font size="0"><pre class="language-c"><code class="language-c">int m,*p;\t\t/*定义2个变量,其中m是整型变量,p是指向整型变量的指针变量*/\nchar *p2,*p3;\t/*定义指向字符型变量的指针变量p2和p3*/\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">初始化</p>`类型说明符 *指针变量名1=地址1,*指针变量名2=地址2…;`<br>\n<font size="0"><pre class="language-c"><code class="language-c">int i;\nint *p=&i;\t    /*定义指针变量p指向整型变量i*/\nchar s[20];\nchar *str=s;\t/*定义指针变量str指向字符数组s的首地址*/\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">初始化</p>给指针变量赋值+引用指针变量指向的变量<br>\n<font size="0"><pre class="language-"><code class="language-">int a=20,b=30,*p1,*p2;\np1=&a;\t\t\t\t/*把变量a的地址赋给指针变量p1*/\n*p2=*p1;\t\t\t/*引用指针变量指向的变量*/\nint *p=&a;          <span style=\'color: red\'>// 引用指针变量的值</span>\n</code></pre></font>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">空指针与void指针</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">空指针</p>\n<p>不指向任何对象的指针即为空指针<br>\n<code>int *p=0;</code>,<code>int *p=NULL;</code><br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">void指针</p>\n<p><code>void *p;</code>,不指定p指向哪种类型的变量<br>\n任何指针都可以赋值给void指针<br>\nvoid指针时必须对其进行强制类型转:<code>int *t=(int*)p;</code>p是void指针<br></p>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">指针与数组</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">定义指向一维数组的指针变量</p>\n<p>使指针变量p指向数组a的第0号元素<br>\n<code>int a[5]={1,2,3,4,5},*p;</code><br>\np=&amp;a[0];等价p=a;<br>\np,a和&amp;a[0]均指向同一单元(数组a的首地址)<br>\np是变量,而a和&amp;a[0]都是常量<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">数组中的指针运算</p>\n<p>加减一个整数:<code>p+n,p-n,p++,++p,p--,--p</code>整数n<br>\n指向同一数组的两个指针变量相减,不能进行加法运算<br>\n通过指针引用数组元素：<code>a[i]</code>,<code>*(a+i)</code>,<code>*(p+i)</code><br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">正确定义数组a和相同类型指针变量p后</p><font size="0"><pre class="language-C"><code class="language-C">p=a,等价于p=&a[0]；\na[i],等价于*(a+i),等价于p[i],等价于*(p+i)；\n&a[i],等价于a+i,等价于&p[i],等价于p+i；\n*p++,等价于*(p++),由于++和*同优先级,结合方向从右向左；\n*(p++),等价于a[i++],执行前p指向a[i],执行后p指向a[i+1];\n(*p)++,表示为p所指向的元素值加1,等价于a[i]++,执行前p指向a[i],执行后p还指向a[i]\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">二维数组元素的地址</p><font size="0"><pre class="language-c"><code class="language-c">int a[4][3];\t\t\t\t\t       /*定义二维数组*/\nprintf("变量a的地址：%d\\n",&a);\t\t    /*输出a的地址*/\nprintf("变量a的长度：%d\\n",sizeof(a));\t/*输出a所占的地址空间*/\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">二维数组元素的地址</p>在二维数组中，`*(a+i)`（即a[i]）又指向一个数组<br>\n`*(a+i)+j`表示这个数组的第j+1个元素的地址，等同于a[i]+j<br>\n访问该元素的值可使用`*(*(a+i)+j)`或`*(a[i]+j)`，也就是a[i][j]<br>\n<font size="0"><pre class="language-c"><code class="language-c">&a\t                            二维数组a的地址\na\t                            二维数组名，指向一维数组a[0]，即0行首地址\na[0]，*(a+0)，*a\t            0行0列元素地址\n&a[i]，a+i\t                    i行首地址\na[i]，*(a+i)\t                i行0列元素a[i][0]的地址\na[i]+j，*(a+i)+j，&a[i][j]\t    i行j列元素a[i][j]的地址\n*(a[i]+j)，*(*(a+i)+j)，a[i][j]\ti行j列元素a[i][j]的值\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">指针与字符串</p>', 'children': [{'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">字符数组存放一个字符串</p><font size="0"><pre class="language-c"><code class="language-c">char str[30]="C language!";\t\t\t\t/*定义字符数组str*/\nprintf("%c\\n",str[3]);\t\t\t\t\t/*用%c格式声明输出str[3]*/\nprintf("%s\\n", str);\t\t\t\t\t/*用%s格式声明输出str*/\n</code></pre></font>'}, {'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">指针变量指向字符数组</p>`char *str="C language!";/*定义字符指针变量str并初始化*/`<br>\n字符指针指向的是一个字符串常量的首地址<br>\n<font size="0"><pre class="language-c"><code class="language-c">char a[50],b[30];\t\t\t/*定义两个字符数组a和b*/\nchar *str1,*str2;\t\t\t/*定义两个指针变量*/\nstr1=a;\t\t\t\t        /*指针变量str1指向数组a的第一个元素*/\nstr2=b;\t\t\t\t        /*指针变量str2指向数组b的第一个元素*/\nwhile (*str1!=\'\\0\')\n\tstr1++;\t\t\t\t    /*找到数组a的结束标记*/\nwhile (*str1++=*str2++);    /*将str2连接到str1的后面*/\nprintf("a+b=%s\\n",a);\t\t/*输出连接后的数组a*/\n</code></pre></font>'}]}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">字符指针与字符数组</p><font size="0"><pre class="language-c"><code class="language-c">char *str="C language!";              <span style=\'color: red\'>// str是一个变量，可以改变str使其指向不同的字符串，但不能改变str所指向的字符串常量的值</span>\nchar string[30]="This is a string.";  <span style=\'color: red\'>// string是一个数组，可以改变数组中保存的内容。</span>\n</code></pre></font>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">指针数组</p>\n<p>数组中的每个元素均为指针类型<br>\n类型标识符 <em>数组名[常量表达式];<code>int *p[5];</code><br>\n数组指针和指针数组<br>\n数组指针是一个指针，其指向的数据类型由一个数组构成（将数组作为一个数据类型看待），如“int (</em>p)[5];”；<br>\n指针数组的本质是一个数组，数组中的每个元素用来保存一个指针变量，如“int <em>p[5];”。<br>\n字符串本身就是一个字符数组<br>\nmchar month[12][10]={"January","February","March","April","May","June","July","August","September","October","November","December"};<br>\nchar </em>month[12]={"January","February","March","April","May","June","July","August","September","October","November","December"};<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">指向指针的指针变量</p>`类型标识符 **指针变量名;`<br>\n<font size="0"><pre class="language-c"><code class="language-c">int x=20;\t\t\t/*定义并初始化整型变量x*/\nint *p=&x;\t\t\t/*定义指针变量p指向变量x*/\nint **q=&p;\t\t/*定义指向指针的指针变量q指向指针p*/\n</code></pre></font>'}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">指针与函数</p>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">指针作为函数的参数</p>', 'children': [{'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">指向简单变量的指针作为函数参数</p>\n<p><code>void swap(int *p1,int *p2)</code>swap函数用于交换两数的值<br>\n<code>int i=2,j=3;swap(&amp;i,&amp;j);</code>调用swap函数，参数为i和j的地址<br></p>'}, {'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">指向数组的指针作为函数参数</p>\n<p>实参用数组名，形参用指针变量:<code>f(int *x,int n)</code><br>\n<code>int a[10];f(a,10);</code><br>\n实参用指针变量，形参用数组名:<code>f(int x[],int n)</code><br>\n<code>int a[10],*p;p=a;f(p,10)</code><br>\n实参和形参都用指针变量:<code>f(int *x,int n)</code><br>\n<code>int a[10],*p;p=a;f(p,10);</code><br></p>'}, {'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">指针数组作函数参数</p>\n<p><code>void sort(char *name[],int n);</code>函数声明,<br>\n<code>static char *name[]={"Follow me","Basic","Great Wall","Fortran","Computer desighn","SQL Server","Program"};</code><br>\n<code>sort(name,N);</code><br></p>'}]}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">函数的返回值为指针</p>\n<p><code>int *func(int x,int y){}</code>返回的指针指向一个整型变量<br></p>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">指向函数的指针</p>\n<p><code>int (*pf)();</code>定义一个指向函数的指针，该函数的返回值为整型数据<br>\n<code>int *f();</code>定义一个返回值为指针的函数，该指针指向一个整型数据<br></p>'}]}]})</script></body>
</html>
