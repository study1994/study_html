<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>PillarNet_nu</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
.hidden-code {
  display: none !important;
}
</style>
<link rel="stylesheet" href="https://study1994.github.io/study_html/npm/mycss/style.css">
</head>
<body>
    <svg id="mindmap"></svg>
    <script src="https://study1994.github.io/study_html/npm/myjs/d3@6.7.0.js"></script>
    <script src="https://study1994.github.io/study_html/npm/myjs/markmap-view@0.13.5.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
    <script>
        (r => {
            setTimeout(r);
        })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{'type': 'root', 'depth': 0, 'content': '', 'children': [{'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">训练过程det3d/models/detectors/pillarnet.py</p><span class=\'hidden-code\' data-code=\'class PillarNet(SingleStageDetector):\n    def forward(self, example, return_loss=True, **kwargs):\n        batch_size = len(example[&amp;#39;metadata&amp;#39;])\n        data = dict(\n            points=example[&amp;#39;points&amp;#39;],     [torch.Size([269832, 5]), torch.Size([231976, 5]), torch.Size([237052, 5]), torch.Size([292753, 5])]\n            batch_size=batch_size,        batch_size=4\n        )\n        bev_feature, backbone_features = self.`extract_feat`(data)        torch.Size([4, 256, 180, 180])+[1440,720,360,180,90]\n        preds, _ = self.`bbox_head`(bev_feature, backbone_features)\n        if return_loss:\n            return self.bbox_head.`loss`(example, preds, self.test_cfg)\n        else:\n            return self.bbox_head.`predict`(example, preds, self.test_cfg)\n\'> </span>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/models/detectors/pillarnet.py</p><span class=\'hidden-code\' data-code=\'class PillarNet(SingleStageDetector):\n    def extract_feat(self, data):\n        sp_tensor = self.`reader`(data)                 # class DynamicPillarFeatureNet   torch.Size([277028, 32])\n        pillar_features = self.`backbone`(sp_tensor)\n        if self.with_neck:\n            x = self.`neck`(pillar_features)    # RPNV2  torch.Size([4, 256, 180, 180])\n        return x, pillar_features\n\'> </span>', 'children': [{'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/models/readers/dynamic_pillar_encoder.py</p><span class=\'hidden-code\' data-code=\'class DynamicPillarFeatureNet(nn.Module):\n    def absl_to_relative(self, absolute):\n        relative = absolute.detach().clone()\n        relative[..., 0] -= self.pc_range[0]\n        relative[..., 1] -= self.pc_range[1]\n        relative[..., 2] -= self.pc_range[2]\n        return relative\n    def forward(self, example, **kwargs):\n        points_list = example.pop(&amp;#39;points&amp;#39;)        # [torch.Size([269832, 5]), torch.Size([231976, 5]), torch.Size([237052, 5]), torch.Size([292753, 5])]\n        device = points_list[0].device\n        if self.virtual:\n            # virtual_point_mask = features[..., -2] == -1\n            # virtual_points = features[virtual_point_mask]\n            # virtual_points[..., -2] = 1\n            # features[..., -2] = 0\n            # features[virtual_point_mask] = virtual_points\n            raise NotImplementedError\n        xyz = []\n        xyz_batch_cnt = []\n        for points in points_list:\n            points = self.absl_to_relative(points)\n            xyz_batch_cnt.append(len(points))\n            xyz.append(points[:, :3])\n        xyz = torch.cat(xyz, dim=0).contiguous()                    # torch.Size([1031613, 3])   以-45,-45,-5为原点的相对位置\n        pt_features = torch.cat(points_list, dim=0).contiguous()    # torch.Size([1031613, 5])\n        xyz_batch_cnt = torch.tensor(xyz_batch_cnt, dtype=torch.int32).to(device)      # torch.Size([4])  多少个点云点\n        sp_tensor = self.`pfn_layers`(xyz, xyz_batch_cnt, pt_features)   # class PillarMaxPooling\n        return sp_tensor\n\'> </span>', 'children': [{'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/ops/pillar_ops/pillar_modules.py</p><span class=\'hidden-code\' data-code=\'class PillarMaxPooling(nn.Module):\n    def forward(self, xyz, xyz_batch_cnt, pt_feature):  # xyz: (N1+N2..., 3)相对位置 + xyz_batch_cnt:  (N1, N2, ...) + point_features: (N1+N2..., C) + spatial_shape: [B, H, W]\n        B = xyz_batch_cnt.shape[0]\n        pillar_indices, pillar_set_indices, group_features = self.`groups`(xyz, xyz_batch_cnt, pt_feature)   # det3d/ops/pillar_ops/pillar_utils.py:PillarQueryAndGroup\n        # torch.Size([277028, 3]); torch.Size([1021213]); torch.Size([1021213, 11])\n        group_features = self.`shared_mlps`(group_features)  # (1, C, L)  torch.Size([1021213, 11])->torch.Size([1021213, 32])  【self.shared_mlps = nn.Sequential(*shared_mlp)】\n        group_features = group_features.transpose(1, 0).contiguous()     # torch.Size([32, 1021213])\n        pillar_features = scatter_max(group_features, pillar_set_indices, pillar_indices.shape[0])   # (C, M)  det3d/ops/pillar_ops/scatter_utils.py:torch.Size([32, 277028])\n        pillar_features = pillar_features.transpose(1, 0)   # (M, C)torch.Size([277028, 32])\n        return spconv.SparseConvTensor(pillar_features, pillar_indices, (self.bev_height, self.bev_width), B)  # pillars: (M1+M2..., 3) [byx]  +  pillar_features: (M, C)\n\'> </span>', 'children': [{'type': 'heading', 'depth': 5, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/ops/pillar_ops/pillar_utils.py</p><span class=\'hidden-code\' data-code=\'class PillarQueryAndGroup(nn.Module):\n    def forward(self, xyz, xyz_batch_cnt, point_features):  # (N1+N2..., 3)相对位置  relative coordinates + (N1+N2...) + (N1+N2..., C)原始位置+特征\n        pillars, pillar_centers, indice_pairs = `gen_indice_pairs`(xyz, xyz_batch_cnt, self.pillar_size,self.spatial_shape, self.z_center) # class GenIndicePairs；（M，3）有M个pillar有值，3为b,y,x; (M,3)每个pillar的x,y,z中心点； indice_pairs(N,3)每个点云及其所在pillar，B,y,x\n        point_set_indices, pillar_set_indices = `flatten_indices`(indice_pairs)           # FlattenIndices--》torch.Size([1021213])；torch.Size([1021213])\n        group_point_features = `gather_feature`(point_features, point_set_indices)        # (L, C)  torch.Size([1031613, 5])+torch.Size([1021213])->torch.Size([1021213, 5])\n        group_point_xyz = gather_feature(xyz, point_set_indices)  # (L, 3) [xyz]            det3d/ops/pillar_ops/group_utils.py           ->torch.Size([1021213, 3])\n        group_pillar_centers = gather_feature(pillar_centers, pillar_set_indices)  # (L, 3)  [xyz]\n        group_pillar_centers = group_point_xyz - group_pillar_centers\n        group_features = torch.cat([group_point_features.detach(), group_point_xyz.detach(),group_pillar_centers.detach()], dim=1)      # torch.Size([1021213, 11])  5+3+3\n        return pillars, pillar_set_indices, group_features                               # torch.Size([277028-体素, 3])(b,x,y); torch.Size([1021213-点云]); torch.Size([1021213, 11])\n\'> </span>', 'children': [{'type': 'heading', 'depth': 6, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/ops/pillar_ops/pillar_utils.py</p><span class=\'hidden-code\' data-code=\'class GenIndicePairs(Function):\n    def forward(ctx, xyz:torch.Tensor, xyz_batch_cnt:torch.Tensor, pillar_size, spatial_shape, z_center):   # z_center为(-5+3)/2=-1\n        B = xyz_batch_cnt.numel()       # 4\n        H, W = spatial_shape            # (1440, 1440)   54*2/0.075=1440\n        device = xyz.device\n        pillar_mask = torch.zeros([B, H, W], dtype=torch.bool, device=device)       # torch.Size([4, 1440, 1440])\n        pillar_cuda.`create_pillar_indices_stack_wrapper`(pillar_size, xyz, xyz_batch_cnt, pillar_mask)  # 0.075, torch.Size([1031613, 3]), [269832, 231976, 237052, 292753],  pillar_mask.sum()=pillar_mask.sum()\n        location = torch.cumsum(pillar_mask.view(-1), 0).int()                      # torch.Size([4, 1440, 1440])；pillar_mask.sum()=277028-->torch.Size([8294400])  tensor([0,0...,277028,277028]\n        M = location[-1].item()                                                     # 277028\n        pillar_bev_indices = location.view(B, H, W) * pillar_mask - 1               # torch.Size([4, 1440, 1440]；大多数为-1，有值的为0到277028-1\n        # create indices (M, 3) [byx] \n        pillars = torch.zeros([M, 3], dtype=torch.int32, device=device)             # torch.Size([277028, 3])->byx     得到277028个pillar里面的每个pillar是哪个位置,x的范围是0-1440，y的范围是0-1440\n        pillar_cuda.`create_pillar_indices_wrapper`(pillar_bev_indices, pillars)\n        indice_pairs = torch.full([xyz.shape[0], 1], -1, dtype=torch.int32, device=device)   # torch.Size([1031613, 1]) 1031613这个点云所在索引\n        # create pillar center [x y z]  值范围再0.5*0.075-(1439+0.5)*0.075=(0.0375,107.9625)\n        pillar_centers = torch.zeros([pillars.shape[0], 3], dtype=torch.float32, device=device, requires_grad=False)   # torch.Size([277028, 3])\n        pillar_centers[:, 0] = (pillars[:, 2] + 0.5) * pillar_size\n        pillar_centers[:, 1] = (pillars[:, 1] + 0.5) * pillar_size\n        pillar_centers[:, 2] = z_center                                   # 每个体素的中心点\n        pillar_cuda.`create_pillar_indice_pairs_stack_wrapper`(pillar_size, xyz, xyz_batch_cnt,pillar_bev_indices, indice_pairs)  # 0.075；归一化的x,y,z;  torch.Size([4, 1440, 1440]；大多数为-1，有值的为0到277028-1\n        return pillars, pillar_centers, indice_pairs      // (N,3) 3为B,y,x;范围外的点云为-1\n\'> </span>', 'children': [{'type': 'heading', 'depth': 7, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/ops/pillar_ops/src/pillar_ops.cpp</p><span class=\'hidden-code\' data-code=\'int create_pillar_indices_stack_wrapper(float bev_size, at::Tensor xyz_tensor, at::Tensor xyz_batch_cnt_tensor, at::Tensor pillar_mask_tensor) {\n\tCHECK_INPUT(xyz_tensor);                 // bev_size(1440,1440)\n\tCHECK_INPUT(xyz_batch_cnt_tensor);\n    CHECK_INPUT(pillar_mask_tensor);\n    int N = xyz_tensor.size(0);        // 这个是相对位置，相对(-54,-54,-5.0) N=1031613,C=3\n    int C = xyz_tensor.size(1);\n\tassert(C == 3);\n    int B = pillar_mask_tensor.size(0);   // B=4为batch size为4总共4个点云\n    int H = pillar_mask_tensor.size(1);   // 1440\n    int W = pillar_mask_tensor.size(2);   // 1440\n    const int *xyz_batch_cnt = xyz_batch_cnt_tensor.data_ptr`<`int`>`();           // 创建指针\n    const float *xyz = xyz_tensor.data_ptr`<`float`>`();\n    bool *pillar_mask = pillar_mask_tensor.data_ptr`<`bool`>`();\n    `create_pillar_indices_stack_kernel_launcher`(N, B, H, W, bev_size, xyz, xyz_batch_cnt, pillar_mask);\n    return 1;\n}\n\'> </span>', 'children': [{'type': 'heading', 'depth': 8, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/ops/pillar_ops/src/pillar_ops_gpu.cu</p><span class=\'hidden-code\' data-code=\'void create_pillar_indices_stack_kernel_launcher(int N, int B, int H, int W, float bev_size,const float *xyz, const int *xyz_batch_cnt, bool *pillar_mask) {\n    cudaError_t err;             // 点云个数1031613  #define THREADS_PER_BLOCK 512\n    dim3 blocks(DIVUP(N, THREADS_PER_BLOCK));  // blockIdx.x(col), blockIdx.y(row)  -#define DIVUP(m,n) ((m) / (n) + ((m) % (n) > 0))\n    dim3 threads(THREADS_PER_BLOCK);\n    `createPillarIndicesStackKernel``<``<``<`blocks, threads`>``>``>`(N, B, H, W, bev_size, xyz, xyz_batch_cnt, pillar_mask);\n    // cudaDeviceSynchronize();  // for using printf in kernel function\n    err = cudaGetLastError();\n    if (cudaSuccess != err) {\n        fprintf(stderr, &amp;#39;CUDA kernel failed: %s\\n&amp;#39;, cudaGetErrorString(err));\n        exit(-1);\n    }\n}\n\'> </span>', 'children': [{'type': 'heading', 'depth': 9, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/ops/pillar_ops/src/pillar_ops_gpu.cu</p><span class=\'hidden-code\' data-code=\'__global__ void createPillarIndicesStackKernel(int N, int B, int H, int W, float bev_size,const float *xyz, const int *xyz_batch_cnt, bool *pillar_mask) {\n\t// xyz_batch_cnt: (N1+N2...)    xyz: (N1+N2..., 3) [x y z ...]\n    // pillar_mask: [B, H, W]\n    const int tid = blockIdx.x * blockDim.x + threadIdx.x;  // 一个值对应一个点云？\n    if (tid >= N) return;\n    xyz += tid * 3;         // 该点云的x,y,z坐标\n    int bid = 0, pts_cnt = xyz_batch_cnt[0]; // N_0\n    for (int b = 1; b < B; ++b){\n    \tif (tid < pts_cnt) break;\n    \tpts_cnt += xyz_batch_cnt[b];     // 如果tid是第一个batch点云里面的点，pts_cnt=N_0，bid=0,如果为第二个batch点云里面的点，pts_cnt=N_0+N_1以此类推,bid=1\n    \tbid = b;\n    }\n    pillar_mask += bid * H * W;\n    float cx = xyz[0] / bev_size;\n    float cy = xyz[1] / bev_size;\n    int xid = int(cx);\n    int yid = int(cy);\n    if (xid `<` 0 || xid `>`= W || yid `<` 0 || yid `>`= H) return;\n    pillar_mask[yid * W + xid] = 1;     // 最终让这个mask知道哪个pillar里面有值为1\n}\n\'> </span>'}]}]}, {'type': 'heading', 'depth': 7, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/ops/pillar_ops/src/pillar_ops.cpp</p><span class=\'hidden-code\' data-code=\'int create_pillar_indices_wrapper(at::Tensor bev_indices_tensor, at::Tensor pillar_indices_tensor) {\n\t// bev_indices_tensor: (B, H, W)       pillar_indices_tensor: (M, 3) [byx]\n\tCHECK_INPUT(bev_indices_tensor);\n\tCHECK_INPUT(pillar_indices_tensor);\n\tint B = bev_indices_tensor.size(0);   // 大多数是-1，一般为0-M-1,其中M是第M个有点云的\n\tint H = bev_indices_tensor.size(1);\n\tint W = bev_indices_tensor.size(2);\n\tconst int *bevIndices = bev_indices_tensor.data_ptr`<`int`>`();\n\tint *pillarIndices = pillar_indices_tensor.data_ptr`<`int`>`();\n\t`create_pillar_indices_kernel_launcher`(B, H, W, bevIndices, pillarIndices);\n\treturn 1;\n}\n\'> </span>', 'children': [{'type': 'heading', 'depth': 8, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/ops/pillar_ops/src/pillar_ops_gpu.cu</p><span class=\'hidden-code\' data-code=\'void create_pillar_indices_kernel_launcher(int B, int H, int W, const int *bevIndices, int *pillarIndices){\n\tcudaError_t err;\n\tdim3 blocks(DIVUP(B * H * W, THREADS_PER_BLOCK));  // blockIdx.x(col), blockIdx.y(row)\n\tdim3 threads(THREADS_PER_BLOCK);\n\t`createPillarIndicesKernel``<``<``<`blocks, threads`>``>``>`(B, H, W, bevIndices, pillarIndices);\n\t// cudaDeviceSynchronize();  // for using printf in kernel function\n\terr = cudaGetLastError();\n\tif (cudaSuccess != err) {\n\t\tfprintf(stderr, &amp;#39;CUDA kernel failed: %s\\n&amp;#39;, cudaGetErrorString(err));\n\t\texit(-1);\n\t}\n}\n\'> </span>', 'children': [{'type': 'heading', 'depth': 9, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/ops/pillar_ops/src/pillar_ops_gpu.cu</p><span class=\'hidden-code\' data-code=\'__global__ void createPillarIndicesKernel(int B, int H, int W, const int *bevIndices, int *pillarIndices){\n\t// pillarIndices: (L, 3)  [bId, yId, xId]   bevIndices: (B*H*W)\n\tconst int tid = blockIdx.x * blockDim.x + threadIdx.x;\n\tif (tid >= B*H*W) return;\n\tbevIndices += tid;\n\tif (bevIndices[0] < 0) return;\n\tint bId = tid / (H * W);\n\tint xId = tid % W;\n\tint yId = (tid / W) % H;\n\tconst int index = bevIndices[0] * 3;\n\tpillarIndices[index + 0] = bId;\n\tpillarIndices[index + 1] = yId;\n\tpillarIndices[index + 2] = xId;\n}\n\'> </span>'}]}]}, {'type': 'heading', 'depth': 7, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/ops/pillar_ops/src/pillar_ops.cpp</p><span class=\'hidden-code\' data-code=\'int create_pillar_indice_pairs_stack_wrapper(float bev_size, at::Tensor xyz_tensor, at::Tensor xyz_batch_cnt_tensor,t::Tensor pillar_bev_indices_tensor, at::Tensor indice_pairs_tensor) {\n\tCHECK_INPUT(xyz_tensor);\n\tCHECK_INPUT(xyz_batch_cnt_tensor);\n    CHECK_INPUT(pillar_bev_indices_tensor);\n    CHECK_INPUT(indice_pairs_tensor);\n    int N = xyz_tensor.size(0);         // N个点云\n    int C = xyz_tensor.size(1);         // c=3\n    assert(C == 3);\n    int B = pillar_bev_indices_tensor.size(0);     // Batch size\n    int H = pillar_bev_indices_tensor.size(1);     // 1440\n    int W = pillar_bev_indices_tensor.size(2);     // 1440\n    const int *xyz_batch_cnt = xyz_batch_cnt_tensor.data_ptr`<`int`>`();\n    const float *xyz = xyz_tensor.data_ptr`<`float`>`();\n    const int *pillar_bev_indices = pillar_bev_indices_tensor.data_ptr`<`int`>`();\n    int *indice_pairs = indice_pairs_tensor.data_ptr`<`int`>`();\n    create_pillar_indice_pairs_stack_kernel_launcher(N, B, H, W, bev_size, xyz, xyz_batch_cnt, pillar_bev_indices, indice_pairs);\n    return 1;\n}\n\'> </span>', 'children': [{'type': 'heading', 'depth': 8, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/ops/pillar_ops/src/pillar_ops_gpu.cu</p><span class=\'hidden-code\' data-code=\'void create_pillar_indice_pairs_stack_kernel_launcher(int N, int B, int H, int W, float bev_size,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const float *xyz, const int *xyz_batch_cnt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const int *pillar_bev_indices, int *indice_pairs) {\n    cudaError_t err;\n    dim3 blocks(DIVUP(N, THREADS_PER_BLOCK));  // blockIdx.x(col), blockIdx.y(row)\n    dim3 threads(THREADS_PER_BLOCK);\n    createPillarIndicePairsStackKernel`<``<``<`blocks, threads`>``>``>`(N, B, H, W, bev_size, xyz, xyz_batch_cnt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   pillar_bev_indices, indice_pairs);\n    // cudaDeviceSynchronize();  // for using printf in kernel function\n    err = cudaGetLastError();\n    if (cudaSuccess != err) {\n        fprintf(stderr, &amp;#39;CUDA kernel failed: %s\\n&amp;#39;, cudaGetErrorString(err));\n        exit(-1);\n    }\n}\n\'> </span>', 'children': [{'type': 'heading', 'depth': 9, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/ops/pillar_ops/src/pillar_ops_gpu.cu</p><span class=\'hidden-code\' data-code=\'__global__ void createPillarIndicePairsStackKernel(int N, int B, int H, int W, float bev_size, const float *xyz, const int *xyz_batch_cnt,const int *pillar_bev_indices, int *indice_pairs) {\n    // pointBatchCnt: (N1+N2...)    points: (N1+N2..., C) [x y z ...]    pillarBevIndices: [B, H, W]\n    // indicePairs: (N1+N2..., 1)\n    const int tid = blockIdx.x * blockDim.x + threadIdx.x;\n    if (tid >= N) return;\n    xyz += tid * 3;\n    indice_pairs += tid;\n    int bid = 0, pts_cnt = xyz_batch_cnt[0];\n    for (int b = 1; b < B; ++b){\n    \tif (tid < pts_cnt) break;\n    \tpts_cnt += xyz_batch_cnt[b];\n    \tbid = b;\n    }\n    const int prefix = bid * H * W;\n    pillar_bev_indices += prefix;\n    const float cx = xyz[0] / bev_size;\n    const float cy = xyz[1] / bev_size;\n    int xid = int(cx);\n    int yid = int(cy);\n    if (xid `<` 0 || xid `>`= W || yid `<` 0 || yid `>`= H) return;\n    indice_pairs[0] = pillar_bev_indices[yid * W + xid];\n}\n\'> </span>'}]}]}]}, {'type': 'heading', 'depth': 6, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/ops/pillar_ops/group_utils.py</p><span class=\'hidden-code\' data-code=\'class FlattenIndices(Function):\n    @staticmethod\n    def forward(ctx, indice_pairs:torch.Tensor):\n        mask = indice_pairs.view(-1) > -1              # torch.Size([1031613, 1])  mask.sum()=1021213为啥还会有-1存在，点云外的值\n        position = torch.cumsum(mask, 0).int()\n        L = position[-1].item()                # 1021213  也就是说1031613个点云有1021213个点云有值\n        position = position * mask - 1         # 点云有pillar的位置\n        first_indices = torch.zeros(L, dtype=torch.int32, device=indice_pairs.device, requires_grad=False)\n        second_indices = torch.zeros(L, dtype=torch.int32, device=indice_pairs.device, requires_grad=False)\n        pillar_cuda.`flatten_indice_pairs_wrapper`(indice_pairs, position, first_indices, second_indices)\n        return first_indices, second_indices\n\'> </span>', 'children': [{'type': 'heading', 'depth': 7, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/ops/pillar_ops/src/group_ops.cpp</p><span class=\'hidden-code\' data-code=\'int flatten_indice_pairs_wrapper(at::Tensor indice_pairs_tensor, at::Tensor position_tensor, at::Tensor first_indices_tensor, at::Tensor second_indices_tensor){\n    // indice_pairs_tensor: (N, K)  position_tensor: (N*K) first_indices_tensor: (L,) second_indices_tensor: (L,)\n    CHECK_INPUT(indice_pairs_tensor);\n    CHECK_INPUT(position_tensor);\n    CHECK_INPUT(first_indices_tensor);\n    CHECK_INPUT(second_indices_tensor);\n    int N = indice_pairs_tensor.size(0);  // N个点云\n    int K = indice_pairs_tensor.size(1);  // K为3\n    const int *indicePairs = indice_pairs_tensor.data_ptr`<`int`>`();\n    const int *position = position_tensor.data_ptr`<`int`>`();\n    int *firstIndices = first_indices_tensor.data_ptr`<`int`>`();\n    int *secondIndices = second_indices_tensor.data_ptr`<`int`>`();\n    `flatten_indice_paris_kernel_launcher`(N, K, indicePairs, position, firstIndices, secondIndices);\n    return 1;\n}\n\'> </span>', 'children': [{'type': 'heading', 'depth': 8, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/ops/pillar_ops/src/group_ops_gpu.cu</p><span class=\'hidden-code\' data-code=\'void flatten_indice_paris_kernel_launcher(int N, int K, const int *indicePairs, const int *position, int *firstIndices, int *secondIndices) {\n    cudaError_t err;\n    dim3 blocks(DIVUP(N*K, THREADS_PER_BLOCK));  // blockIdx.x(col), blockIdx.y(row)\n    dim3 threads(THREADS_PER_BLOCK);\n    `flattenIndicePairsKernel``<``<``<`blocks, threads`>``>``>`(N, K, indicePairs, position, firstIndices, secondIndices);\n    err = cudaGetLastError();\n    if (cudaSuccess != err) {\n        fprintf(stderr, &amp;#39;CUDA kernel failed (flattenIndicePairsKernel): %s\\n&amp;#39;, cudaGetErrorString(err));\n        exit(-1);\n    }\n}\n\'> </span>', 'children': [{'type': 'heading', 'depth': 9, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/ops/pillar_ops/src/group_ops_gpu.cu</p><span class=\'hidden-code\' data-code=\'__global__ void flattenIndicePairsKernel(int N, int K, const int *indicePairs, const int *position,\n                                         int *firstIndices, int *secondIndices) {\n    // indicePairs: (N, K) -1[none]  position: (N*K, )  -1[none]\n    // firstIndices: (L,)            secondIndices: (L,)\n    const int tid = blockIdx.x * blockDim.x + threadIdx.x;\n    if (tid >= N * K) return;\n    indicePairs += tid;\n    position += tid;\n    if (indicePairs[0] < 0) return;\n    int index = position[0];\n    firstIndices[index] = tid / K;\n    secondIndices[index] = indicePairs[0];\n}\n\'> </span>'}]}]}]}, {'type': 'heading', 'depth': 6, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/ops/pillar_ops/group_utils.py</p><span class=\'hidden-code\' data-code=\'class GatherFeature(Function):\n    def forward(ctx, features:torch.Tensor, set_indices:torch.Tensor):\n        new_features = features.new_zeros((set_indices.shape[0], features.shape[1]))       # torch.Size([1021213, 5])\n        pillar_cuda.gather_feature_wrapper(set_indices, features, new_features)\n        ctx.for_backwards = (features.shape[0], features.shape[1], set_indices)\n        return new_features\n    def backward(ctx, grad_out):\n        N, C, set_indices = ctx.for_backwards\n        grad_features = Variable(torch.cuda.FloatTensor(N, C).zero_())\n        grad_out_data = grad_out.data.contiguous()\n        pillar_cuda.gather_feature_grad_wrapper(set_indices, grad_out_data, grad_features)\n        return grad_features, None\n\'> </span>'}]}]}]}, {'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/models/backbones/pcnres18.py</p><span class=\'hidden-code\' data-code=\'class SpMiddlePillarEncoder18(nn.Module):\n    def forward(self, sp_tensor):\n        x_conv1 = self.conv1(sp_tensor)   # spconv.pytorch.core.SparseConvTensor(torch.Size([277028, 32]),torch.Size([277028, 3]),[1440, 1440],4)->SparseConvTensor(torch.Size([277028, 32]),torch.Size([277028, 3]),[1440, 1440],4)\n        x_conv2 = self.conv2(x_conv1)     # SparseConvTensor(torch.Size([166641, 64]),torch.Size([166641, 3]),[720, 720],4)\n        x_conv3 = self.conv3(x_conv2)     # SparseConvTensor(torch.Size([70167, 128]),torch.Size([70167, 3]),[360, 360],4)\n        x_conv4 = self.conv4(x_conv3)     # SparseConvTensor(torch.Size([28006, 256]),torch.Size([28006, 3]),[180, 180],4)\n        x_conv4 = x_conv4.dense()         # torch.Size([4, 256, 180, 180])\n        x_conv5 = self.conv5(x_conv4)     # torch.Size([4, 256, 90, 90])\n        return dict(\n            x_conv1=x_conv1,\n            x_conv2=x_conv2,\n            x_conv3=x_conv3,\n            x_conv4=x_conv4,\n            x_conv5=x_conv5\n        )\n\'> </span>'}, {'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/models/necks/rpn.py</p><span class=\'hidden-code\' data-code=\'class RPNV2(nn.Module):\n    def forward(self, pillar_features, **kwargs):\n        x_conv4 = pillar_features[&amp;#39;x_conv4&amp;#39;]         # torch.Size([4, 256, 180, 180])\n        x_conv5 = pillar_features[&amp;#39;x_conv5&amp;#39;]         # torch.Size([4, 256, 90, 90])\n        if isinstance(x_conv4, spconv.SparseConvTensor):\n            x_conv4 = x_conv4.dense()\n        if isinstance(x_conv5, spconv.SparseConvTensor):\n            x_conv5 = x_conv5.dense()\n        ups = [self.deblock_4(x_conv4)]     # [torch.Size([4, 128, 180, 180])]\n        x = self.block_5(x_conv5)           # torch.Size([4, 256, 90, 90])\n        ups.append(self.deblock_5(x))\n        x = torch.cat(ups, dim=1)           # torch.Size([4, 256, 180, 180])\n        x = self.block_4(x)                 # torch.Size([4, 256, 180, 180])\n        return x\n\'> </span>'}]}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/models/bbox_heads/center_head.py</p><span class=\'hidden-code\' data-code=\'class CenterHead(nn.Module):\n    def forward(self, x, *kwargs):\n        ret_dicts = []\n        x = self.shared_conv(x)        # torch.Size([4, 256, 180, 180])->torch.Size([4, 64, 180, 180])\n        for task in self.tasks:\n            ret_dicts.append(task(x))\n        return ret_dicts, x            # len(ret_dicts)==6;\n        # [(key,value.shape) for key,value in ret_dicts[0].items()]\n        # (&amp;#39;reg&amp;#39;, torch.Size([4, 2, 180, 180]))\n        # (&amp;#39;height&amp;#39;, torch.Size([4, 1, 180, 180]))\n        # (&amp;#39;dim&amp;#39;, torch.Size([4, 3, 180, 180]))\n        # (&amp;#39;rot&amp;#39;, torch.Size([4, 2, 180, 180]))\n        # (&amp;#39;vel&amp;#39;, torch.Size([4, 2, 180, 180]))\n        # (&amp;#39;iou&amp;#39;, torch.Size([4, 1, 180, 180]))\n        # (&amp;#39;hm&amp;#39;, torch.Size([4, 1, 180, 180]))\n\'> </span>'}, {'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/models/bbox_heads/center_head.py</p><span class=\'hidden-code\' data-code=\'class CenterHead(nn.Module):\n    def loss(self, example, preds_dicts, test_cfg, **kwargs):\n        rets = []\n        for task_id, preds_dict in enumerate(preds_dicts):\n            preds_dict[&amp;#39;hm&amp;#39;] = self._sigmoid(preds_dict[&amp;#39;hm&amp;#39;])   # heatmap focal loss\n            hm_loss = self.`crit`(preds_dict[&amp;#39;hm&amp;#39;], example[&amp;#39;hm&amp;#39;][task_id], example[&amp;#39;ind&amp;#39;][task_id], example[&amp;#39;mask&amp;#39;][task_id], example[&amp;#39;cat&amp;#39;][task_id])  # FastFocalLoss()\n            target_box = example[&amp;#39;anno_box&amp;#39;][task_id]                    # torch.Size([4, 500, 10])                  # reconstruct the anno_box from multiple reg heads\n            if self.dataset in [&amp;#39;waymo&amp;#39;, &amp;#39;nuscenes&amp;#39;]:\n                if &amp;#39;vel&amp;#39; in preds_dict:\n                    preds_dict[&amp;#39;anno_box&amp;#39;] = torch.cat((preds_dict[&amp;#39;reg&amp;#39;], preds_dict[&amp;#39;height&amp;#39;], preds_dict[&amp;#39;dim&amp;#39;],preds_dict[&amp;#39;vel&amp;#39;], preds_dict[&amp;#39;rot&amp;#39;]), dim=1)  \n                else:\n                    preds_dict[&amp;#39;anno_box&amp;#39;] = torch.cat((preds_dict[&amp;#39;reg&amp;#39;], preds_dict[&amp;#39;height&amp;#39;], preds_dict[&amp;#39;dim&amp;#39;],preds_dict[&amp;#39;rot&amp;#39;]), dim=1)   \n                    target_box = target_box[..., [0, 1, 2, 3, 4, 5, -2, -1]] # remove vel target                       \n            else:\n                raise NotImplementedError()\n            ret = {}            # Regression loss for dimension, offset, height, rotation             \n            box_loss = self.`crit_reg`(preds_dict[&amp;#39;anno_box&amp;#39;], example[&amp;#39;mask&amp;#39;][task_id], example[&amp;#39;ind&amp;#39;][task_id], target_box)  # RegLoss()  torch.Size([4, 10, 180, 180]),torch.Size([4, 500]),torch.Size([4, 500]),torch.Size([4, 500, 10])\n            loc_loss = (box_loss*box_loss.new_tensor(self.code_weights)).sum()\n            loss = hm_loss + self.weight * loc_loss                               # torch.Size([10])  [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.2, 0.2, 1.0, 1.0]\n            ret.update({&amp;#39;hm_loss&amp;#39;: hm_loss.detach().cpu(),&amp;#39;loc_loss&amp;#39;: loc_loss, &amp;#39;loc_loss_elem&amp;#39;: box_loss.detach().cpu(),&amp;#39;num_positive&amp;#39;: example[&amp;#39;mask&amp;#39;][task_id].float().sum()})\n            if self.with_iou or self.with_iou_reg:\n                batch_dim = torch.exp(torch.clamp(preds_dict[&amp;#39;dim&amp;#39;], min=-5, max=5))\n                batch_dim = batch_dim.permute(0, 2, 3, 1).contiguous()                      # torch.Size([4, 3, 180, 180])->torch.Size([4, 180, 180, 3])\n                batch_rot = preds_dict[&amp;#39;rot&amp;#39;].clone(); batch_rot = batch_rot.permute(0, 2, 3, 1).contiguous()\n                batch_rots = batch_rot[..., 0:1]                                            \n                batch_rotc = batch_rot[..., 1:2]\n                batch_reg = preds_dict[&amp;#39;reg&amp;#39;].clone().permute(0, 2, 3, 1).contiguous()\n                batch_hei = preds_dict[&amp;#39;height&amp;#39;].clone().permute(0, 2, 3, 1).contiguous()\n                batch_rot = torch.atan2(batch_rots, batch_rotc)                             # torch.Size([4, 180, 180, 1])\n                batch, H, W, _ = batch_dim.size()                                           # 180,180\n                batch_reg = batch_reg.reshape(batch, H * W, 2)                              # torch.Size([4, 32400, 2])\n                batch_hei = batch_hei.reshape(batch, H * W, 1)                              # torch.Size([4, 32400, 1])\n                batch_rot = batch_rot.reshape(batch, H * W, 1)                              # torch.Size([4, 32400, 1])\n                batch_dim = batch_dim.reshape(batch, H * W, 3)                              # torch.Size([4, 32400, 3])\n                ys, xs = torch.meshgrid([torch.arange(0, H), torch.arange(0, W)])\n                ys = ys.view(1, H, W).repeat(batch, 1, 1).to(batch_dim)            # torch.Size([4, 180, 180])\n                xs = xs.view(1, H, W).repeat(batch, 1, 1).to(batch_dim)            # torch.Size([4, 180, 180])\n                xs = xs.view(batch, -1, 1) + batch_reg[:, :, 0:1]                  # torch.Size([4, 32400, 1])+torch.Size([4, 32400, 1])=torch.Size([4, 32400, 1])\n                ys = ys.view(batch, -1, 1) + batch_reg[:, :, 1:2]\n                xs = xs * int(self.task_strides[task_id]) * test_cfg.voxel_size[0] + test_cfg.pc_range[0]     # x*8*0.075+(-54)\n                ys = ys * int(self.task_strides[task_id]) * test_cfg.voxel_size[1] + test_cfg.pc_range[1]\n                batch_box_preds = torch.cat([xs, ys, batch_hei, batch_dim, batch_rot], dim=2)\n                batch_box_preds = batch_box_preds.permute(0, 2, 1).contiguous().reshape(batch, -1, H, W)      # 得到预测的3D box\n                if self.with_iou:                                                    # 预测iou的分支计算损失\n                    pred_boxes_for_iou = batch_box_preds.detach()\n                    iou_loss = self.`crit_iou`(preds_dict[&amp;#39;iou&amp;#39;], example[&amp;#39;mask&amp;#39;][task_id], example[&amp;#39;ind&amp;#39;][task_id],pred_boxes_for_iou, example[&amp;#39;gt_box&amp;#39;][task_id])  # IouLoss\n                    loss = loss + iou_loss\n                    ret.update({&amp;#39;iou_loss&amp;#39;: iou_loss.detach().cpu()})\n                if self.with_iou_reg:                                                # 增加iou损失\n                    iou_reg_loss = self.`crit_iou_reg`(batch_box_preds, example[&amp;#39;mask&amp;#39;][task_id], example[&amp;#39;ind&amp;#39;][task_id],example[&amp;#39;gt_box&amp;#39;][task_id])                # RegLoss\n                    loss = loss + self.weight * iou_reg_loss\n                    ret.update({&amp;#39;iou_reg_loss&amp;#39;: iou_reg_loss.detach().cpu()})\n            ret.update({&amp;#39;loss&amp;#39;: loss})\n            rets.append(ret)\n\'> </span>', 'children': [{'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/models/losses/centernet_loss.py</p><span class=\'hidden-code\' data-code=\'class FastFocalLoss(nn.Module):\n    def __init__(self):\n    def forward(self, out, target, ind, mask, cat):  # torch.Size([4, 1, 180, 180]); torch.Size([4, 1, 180, 180]); torch.Size([4, 500]); torch.Size([4, 500]); torch.Size([4, 500])\n        mask = mask.float()\n        gt = torch.pow(1 - target, 4)\n        neg_loss = torch.log(1 - out) * torch.pow(out, 2) * gt     # torch.Size([4, 1, 180, 180])\n        neg_loss = neg_loss.sum()                                  # tensor(-1378.7615, device=&amp;#39;cuda:0&amp;#39;, grad_fn=`<`SumBackward0`>`)\n        pos_pred_pix = `_transpose_and_gather_feat`(out, ind) # B x M x C    torch.Size([4, 500, 1])\n        pos_pred = pos_pred_pix.gather(2, cat.unsqueeze(2)) # B x M        torch.Size([4, 500, 1])+ torch.Size([4, 500, 1])->torch.Size([4, 500, 1])\n        num_pos = mask.sum()                                # tensor(34., device=&amp;#39;cuda:0&amp;#39;)\n        pos_loss = torch.log(pos_pred) * torch.pow(1 - pos_pred, 2) * mask.unsqueeze(2)      # torch.Size([4, 500, 1])\n        pos_loss = pos_loss.sum()            # tensor(-52.1852, device=&amp;#39;cuda:0&amp;#39;, grad_fn=`<`SumBackward0`>`)\n        if num_pos == 0:\n            return - neg_loss\n        return - (pos_loss + neg_loss) / num_pos\n\'> </span>', 'children': [{'type': 'heading', 'depth': 4, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/core/utils/center_utils.py</p><span class=\'hidden-code\' data-code=\'def _transpose_and_gather_feat(feat, ind):              # torch.Size([4, 1, 180, 180])  torch.Size([4, 500])里面的每个值都是y*180-x\n    feat = feat.permute(0, 2, 3, 1).contiguous()        # torch.Size([4, 1, 180, 180])->torch.Size([4, 180, 180, 1])->torch.Size([4, 32400, 1])\n    feat = feat.view(feat.size(0), -1, feat.size(3))\n    feat = _gather_feat(feat, ind)\n    return feat\n\'> </span>', 'children': [{'type': 'heading', 'depth': 5, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/core/utils/center_utils.py</p><span class=\'hidden-code\' data-code=\'def _gather_feat(feat, ind, mask=None):                # torch.Size([4, 32400, 1])->torch.Size([4, 500])\n    dim  = feat.size(2)                                # 1\n    ind  = ind.unsqueeze(2).expand(ind.size(0), ind.size(1), dim)  # torch.Size([4, 500])->torch.Size([4, 500,1])\n    feat = feat.gather(1, ind)                         # torch.Size([4, 500, 1])\n    if mask is not None:\n        mask = mask.unsqueeze(2).expand_as(feat)\n        feat = feat[mask]\n        feat = feat.view(-1, dim)\n    return feat                                         # torch.Size([4, 500, 1])\n\'> </span>'}]}]}, {'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/models/losses/centernet_loss.py</p><span class=\'hidden-code\' data-code=\'class IouLoss(nn.Module):\n  def __init__(self):\n    super(IouLoss, self).__init__()\n  def forward(self, iou_pred, mask, ind, box_pred, box_gt):\n    if mask.sum() == 0:\n      return iou_pred.new_zeros((1))\n    mask = mask.bool()\n    pred = _transpose_and_gather_feat(iou_pred, ind)[mask]\n    pred_box = _transpose_and_gather_feat(box_pred, ind)\n    target = boxes_aligned_iou3d_gpu(pred_box[mask], box_gt[mask])\n    target = 2 * target - 1\n    loss = F.l1_loss(pred, target, reduction=&amp;#39;sum&amp;#39;)\n    loss = loss / (mask.sum() + 1e-4)\n    return loss\n\'> </span>'}, {'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/models/losses/centernet_loss.py</p><span class=\'hidden-code\' data-code=\'class RegLoss(nn.Module):\n  def __init__(self):\n    super(RegLoss, self).__init__()\n  \n  def forward(self, output, mask, ind, target):\n    if mask.sum() == 0:\n      return output.new_zeros((target.shape[-1]))\n    pred = _transpose_and_gather_feat(output, ind)\n    mask = mask.float().unsqueeze(2)\n    loss = F.l1_loss(pred*mask, target*mask, reduction=&amp;#39;none&amp;#39;)\n    loss = loss / (mask.sum() + 1e-4)\n    loss = loss.transpose(2 ,0).sum(dim=2).sum(dim=1)\n    return loss\n\'> </span>'}]}]}, {'type': 'heading', 'depth': 1, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">预测流程det3d/models/detectors/pillarnet.py</p><span class=\'hidden-code\' data-code=\'class PillarNet(SingleStageDetector):\n    def forward_two_stage(self, example, return_loss=True, **kwargs):\n        batch_size = len(example[&amp;#39;metadata&amp;#39;])\n        data = dict(points=example[&amp;#39;points&amp;#39;],batch_size=batch_size,)\n        bev_feature, backbone_features = self.extract_feat(data)\n        preds, _ = self.bbox_head(bev_feature, backbone_features)\n        boxes = self.bbox_head.`predict`(example, new_preds, self.test_cfg)\n        if return_loss:\n            return boxes, bev_feature, backbone_features, self.bbox_head.loss(example, preds, self.test_cfg)\n        else:\n            return boxes, bev_feature, backbone_features, None\n\'> </span>', 'children': [{'type': 'heading', 'depth': 2, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/models/bbox_heads/center_head.py</p><span class=\'hidden-code\' data-code=\'class CenterHead(nn.Module):\n    def predict(self, example, preds_dicts, test_cfg, **kwargs):\n        rets = []\n        metas = []\n        double_flip = test_cfg.get(&amp;#39;double_flip&amp;#39;, False)            # True\n        post_center_range = test_cfg.post_center_limit_range        # [-61.2, -61.2, -10.0, 61.2, 61.2, 10.0]\n        if len(post_center_range) > 0:\n            post_center_range = torch.tensor(post_center_range,dtype=preds_dicts[0][&amp;#39;hm&amp;#39;].dtype,device=preds_dicts[0][&amp;#39;hm&amp;#39;].device,)\n        for task_id, preds_dict in enumerate(preds_dicts):            \n            for key, val in preds_dict.items():\n                preds_dict[key] = val.permute(0, 2, 3, 1).contiguous()  # convert N C H W to N H W C \n            batch_size = preds_dict[&amp;#39;hm&amp;#39;].shape[0]    # 24\n            if double_flip:\n                ......\n            if &amp;#39;metadata&amp;#39; not in example or len(example[&amp;#39;metadata&amp;#39;]) == 0:\n                meta_list = [None] * batch_size\n            else:\n                meta_list = example[&amp;#39;metadata&amp;#39;]\n                if double_flip:\n                    meta_list = meta_list[:4*int(batch_size):4]\n            batch_hm = torch.sigmoid(preds_dict[&amp;#39;hm&amp;#39;])\n            batch_dim = torch.exp(torch.clamp(preds_dict[&amp;#39;dim&amp;#39;].clone(), min=-5, max=5))\n            if &amp;#39;iou&amp;#39; in preds_dict.keys():\n                batch_iou = (preds_dict[&amp;#39;iou&amp;#39;].squeeze(dim=-1) + 1) * 0.5    # torch.Size([6, 4, 180, 180, 1])  target = 2 * target - 1;target范围0-1，最后得到-1->1这里预测(-1->1)还原到(0,1)\n                batch_iou = batch_iou.type_as(batch_dim)\n            else:\n                batch_iou = torch.ones((batch_hm.shape[0], batch_hm.shape[1], batch_hm.shape[2]),dtype=batch_dim.dtype).to(batch_hm.device)\n            batch_rots = preds_dict[&amp;#39;rot&amp;#39;][..., 0:1]\n            batch_rotc = preds_dict[&amp;#39;rot&amp;#39;][..., 1:2]\n            batch_reg = preds_dict[&amp;#39;reg&amp;#39;]\n            batch_hei = preds_dict[&amp;#39;height&amp;#39;]\n            if double_flip:\n                ......\n            batch_rot = torch.atan2(batch_rots, batch_rotc)\n            batch, H, W, num_cls = batch_hm.size()\n            batch_reg = batch_reg.reshape(batch, H*W, 2)\n            batch_hei = batch_hei.reshape(batch, H*W, 1)\n            batch_rot = batch_rot.reshape(batch, H*W, 1)\n            batch_dim = batch_dim.reshape(batch, H*W, 3)\n            batch_hm = batch_hm.reshape(batch, H*W, num_cls)\n            ys, xs = torch.meshgrid([torch.arange(0, H), torch.arange(0, W)])\n            ys = ys.view(1, H, W).repeat(batch, 1, 1).to(batch_hm)\n            xs = xs.view(1, H, W).repeat(batch, 1, 1).to(batch_hm)\n            xs = xs.view(batch, -1, 1) + batch_reg[:, :, 0:1]       # x,y\n            ys = ys.view(batch, -1, 1) + batch_reg[:, :, 1:2]\n            xs = xs * int(self.task_strides[task_id]) * test_cfg.voxel_size[0] + test_cfg.pc_range[0]  # x*8*0.075+(-54)预测范围(0,180),得到范围(-54,54)\n            ys = ys * int(self.task_strides[task_id]) * test_cfg.voxel_size[1] + test_cfg.pc_range[1]\n            if &amp;#39;vel&amp;#39; in preds_dict:\n                batch_vel = preds_dict[&amp;#39;vel&amp;#39;]\n                if double_flip:\n                    ......\n                batch_vel = batch_vel.reshape(batch, H*W, 2)\n                batch_box_preds = torch.cat([xs, ys, batch_hei, batch_dim, batch_vel, batch_rot], dim=2)\n            else: \n                batch_box_preds = torch.cat([xs, ys, batch_hei, batch_dim, batch_rot], dim=2)\n            metas.append(meta_list)\n            if test_cfg.get(&amp;#39;per_class_nms&amp;#39;, False):\n                pass \n            else:\n                rets.append(self.`post_processing`(batch_box_preds, batch_hm, batch_iou, test_cfg, post_center_range, task_id))\n\'> </span>', 'children': [{'type': 'heading', 'depth': 3, 'payload': {'lines': [0, 1]}, 'content': '<p style="color: blue;font-weight: bold;">det3d/models/bbox_heads/center_head.py</p><span class=\'hidden-code\' data-code=\'class CenterHead(nn.Module):\n    def post_processing(self, batch_box_preds, batch_hm, batch_iou, test_cfg, post_center_range, task_id):\n        batch_size = len(batch_hm)            # 6\n        prediction_dicts = []\n        for i in range(batch_size):\n            box_preds = batch_box_preds[i]          # torch.Size([32400, 9])  180*180=32400\n            hm_preds = batch_hm[i]                  # torch.Size([32400, 1])\n            iou_preds = batch_iou[i].view(-1)       # torch.Size([32400])\n            num_class = hm_preds.shape[1]           # 1\n            scores, labels = torch.max(hm_preds, dim=-1)\n            score_mask = scores > test_cfg.score_threshold        # 0.1\n            distance_mask = (box_preds[..., :3] `>`= post_center_range[:3]).all(1) &amp; (box_preds[..., :3] `<`= post_center_range[3:]).all(1)\n            mask = distance_mask &amp; score_mask \n            box_preds = box_preds[mask]            # torch.Size([99, 9])\n            scores = scores[mask]                  # torch.Size([99])\n            labels = labels[mask]                  # torch.Size([99])\n            iou_preds = torch.clamp(iou_preds[mask], min=0, max=1.)        # torch.Size([99])\n            boxes_for_nms = box_preds[:, [0, 1, 2, 3, 4, 5, -1]]\n            if test_cfg.get(&amp;#39;circular_nms&amp;#39;, False):\n                centers = boxes_for_nms[:, [0, 1]] \n                boxes = torch.cat([centers, scores.view(-1, 1)], dim=1)\n                selected = _circle_nms(boxes, min_radius=test_cfg.min_radius[task_id],post_max_size=test_cfg.nms.nms_post_max_size[task_id])\n                selected_boxes = box_preds[selected]\n                selected_scores = scores[selected]\n                selected_labels = labels[selected]\n            elif test_cfg.nms.get(&amp;#39;use_rotate_nms&amp;#39;, False):         # True\n                scores = torch.pow(scores, 1-test_cfg.rectifier[task_id]) * torch.pow(iou_preds, test_cfg.rectifier[task_id])    # test_cfg.rectifier=[0.5, 0.5, 0.5, 0.5, 0.5, 0.5]\n                selected = box_torch_ops.rotate_nms_pcdet(boxes_for_nms.float(), scores.float(),\n                                                          thresh=test_cfg.nms.nms_iou_threshold[task_id],        # [0.2, 0.2, 0.2, 0.2, 0.2, 0.2]\n                                                          pre_maxsize=test_cfg.nms.nms_pre_max_size[task_id],    # [1000, 1000, 1000, 1000, 1000, 1000]\n                                                          post_max_size=test_cfg.nms.nms_post_max_size[task_id]) # [83, 83, 83, 83, 83, 83]\n                selected_boxes = box_preds[selected]\n                selected_scores = scores[selected]\n                selected_labels = labels[selected]\n            elif test_cfg.nms.get(&amp;#39;use_multi_class_nms&amp;#39;, False):\n                selected_boxes, selected_scores, selected_labels = box_torch_ops.rotate_class_specific_nms_iou_pcdet(\n                    boxes_for_nms.float(), scores.float(), iou_preds, box_preds, labels, num_class,\n                    test_cfg.rectifier[task_id],\n                    thresh=test_cfg.nms.nms_iou_threshold[task_id],\n                    pre_maxsize=test_cfg.nms.nms_pre_max_size[task_id],\n                    post_max_size=test_cfg.nms.nms_post_max_size[task_id])\n            else:\n                raise NotImplementedError\n            prediction_dict = {\n                &amp;#39;box3d_lidar&amp;#39;: selected_boxes,\n                &amp;#39;scores&amp;#39;: selected_scores,\n                &amp;#39;label_preds&amp;#39;: selected_labels\n            }\n            prediction_dicts.append(prediction_dict)\n        return prediction_dicts \n\'> </span>'}]}]}]})</script><script src='https://study1994.github.io/study_html/npm/myjs/tooltip.js'></script>
</body>
</html>
